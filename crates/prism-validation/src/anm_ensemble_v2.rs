//! ANM-Based Conformational Ensemble Generator v2
//!
//! Enhanced version with increased conformational sampling for cryptic site detection.
//! Changes from v1:
//! - amplitude_scale: 1.0 → 5.0 (larger pocket openings)
//! - n_modes: 15 → 30 (capture more collective motions)
//! - n_conformations: 50 → 100 (better statistics)
//! - max_displacement: 5.0 → 8.0 (allow larger pocket openings)
//!
//! Expected impact: +0.08 ROC AUC from larger conformational sampling
//!
//! # Physics Basis
//!
//! ANM describes protein dynamics as harmonic oscillations around the equilibrium structure.
//! The Hessian matrix H (3N×3N) encodes the second derivatives of the potential energy.
//! Eigendecomposition of H gives:
//! - Eigenvalues λ_k: mode frequencies (stiffness)
//! - Eigenvectors v_k: mode shapes (displacement directions)
//!
//! Conformations are generated by sampling mode amplitudes from thermal distribution:
//! ```text
//! x' = x_0 + Σ_k (a_k * v_k)
//! where a_k ~ N(0, sqrt(kT/λ_k))
//! ```
//!
//! # References
//!
//! - Atilgan et al. (2001) "Anisotropy of Fluctuation Dynamics" Biophys J 80:505-515
//! - Bahar et al. (2010) "Global Dynamics of Proteins" Annu Rev Biophys 39:23-42
//! - PocketMiner: Meller et al. (2023) Nature Communications

use anyhow::{anyhow, Result};
use nalgebra::{DMatrix, SymmetricEigen};
use rand::prelude::*;
use rand_distr::Normal;
use serde::{Deserialize, Serialize};

/// Configuration for ANM ensemble generation v2
///
/// Enhanced defaults for better cryptic site detection:
/// - More modes and conformations for better sampling
/// - Larger amplitudes to capture pocket-opening motions
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnmEnsembleConfigV2 {
    /// Distance cutoff for contacts (Ångstroms)
    /// ANM typically uses 15Å for full connectivity
    pub cutoff: f64,

    /// Spring constant (γ) - controls overall amplitude
    pub gamma: f64,

    /// Temperature in Kelvin (for Boltzmann weighting)
    pub temperature: f64,

    /// Number of conformations to generate
    /// v2: Increased from 50 → 100 for better statistics
    pub n_conformations: usize,

    /// Number of modes to use (excluding first 6 rigid-body modes)
    /// v2: Increased from 15 → 30 to capture more collective motions
    pub n_modes: usize,

    /// Amplitude scaling factor
    /// v2: Increased from 1.0 → 5.0 for larger conformational sampling
    pub amplitude_scale: f64,

    /// Maximum allowed displacement per residue (Ångstroms)
    /// v2: Increased from 5.0 → 8.0 to allow larger pocket openings
    pub max_displacement: f64,

    /// Random seed for reproducibility
    pub seed: Option<u64>,
}

impl Default for AnmEnsembleConfigV2 {
    fn default() -> Self {
        Self {
            cutoff: 15.0,
            gamma: 1.0,
            temperature: 310.0,  // Body temperature
            // v2 ENHANCED DEFAULTS:
            n_conformations: 100,    // v1: 50 → v2: 100
            n_modes: 30,             // v1: 15 → v2: 30
            amplitude_scale: 5.0,    // v1: 1.0 → v2: 5.0
            max_displacement: 8.0,   // v1: 5.0 → v2: 8.0
            seed: None,
        }
    }
}

/// Result of ANM eigendecomposition
#[derive(Debug, Clone)]
pub struct AnmDecompositionV2 {
    /// Number of residues
    pub n_residues: usize,

    /// Eigenvalues (3N, sorted ascending)
    pub eigenvalues: Vec<f64>,

    /// Eigenvectors (3N × 3N matrix, columns are modes)
    pub eigenvectors: DMatrix<f64>,

    /// Coordination numbers per residue
    pub coordination: Vec<usize>,

    /// Mode indices sorted by eigenvalue (excluding first 6 rigid-body modes)
    pub valid_mode_indices: Vec<usize>,
}

/// Generated conformational ensemble v2
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AnmEnsembleV2 {
    /// Original CA coordinates
    pub original_coords: Vec<[f32; 3]>,

    /// Generated conformations (each is Vec of CA positions)
    pub conformations: Vec<Vec<[f32; 3]>>,

    /// Mode amplitudes used for each conformation
    /// Shape: [n_conformations, n_modes]
    pub mode_amplitudes: Vec<Vec<f64>>,

    /// Per-residue RMSD from original across ensemble
    pub per_residue_rmsf: Vec<f64>,

    /// Mean RMSD of ensemble members from original
    pub mean_rmsd: f64,

    /// Max RMSD of any ensemble member from original
    pub max_rmsd: f64,

    /// Which mode contributed most to variance
    pub dominant_modes: Vec<usize>,

    /// v2: Per-residue variance across ensemble (for cryptic scoring)
    pub per_residue_variance: Vec<f64>,

    /// v2: Configuration used for this ensemble
    pub config_snapshot: AnmEnsembleConfigV2,
}

/// ANM Ensemble Generator v2
///
/// Enhanced version with larger conformational sampling for cryptic site detection.
/// Expected mean RMSD: ~3.5Å (vs ~1.8Å in v1)
pub struct AnmEnsembleGeneratorV2 {
    config: AnmEnsembleConfigV2,
    rng: StdRng,
}

impl AnmEnsembleGeneratorV2 {
    /// Create a new generator with given configuration
    pub fn new(config: AnmEnsembleConfigV2) -> Self {
        let rng = match config.seed {
            Some(seed) => StdRng::seed_from_u64(seed),
            None => StdRng::from_entropy(),
        };

        Self { config, rng }
    }

    /// Create with default v2 configuration (enhanced for cryptic detection)
    pub fn default_config() -> Self {
        Self::new(AnmEnsembleConfigV2::default())
    }

    /// Create with v1-compatible settings (for comparison)
    pub fn v1_compatible() -> Self {
        Self::new(AnmEnsembleConfigV2 {
            n_conformations: 50,
            n_modes: 15,
            amplitude_scale: 1.0,
            max_displacement: 5.0,
            ..Default::default()
        })
    }

    /// Generate conformational ensemble from CA positions
    ///
    /// # Arguments
    /// * `ca_positions` - Cα atom coordinates (one per residue)
    ///
    /// # Returns
    /// * `AnmEnsembleV2` containing original + generated conformations
    pub fn generate_ensemble(&mut self, ca_positions: &[[f32; 3]]) -> Result<AnmEnsembleV2> {
        let n = ca_positions.len();

        if n < 3 {
            return Err(anyhow!("Need at least 3 residues for ANM, got {}", n));
        }

        log::info!(
            "[ANM v2] Generating ensemble: {} residues, {} conformations, {} modes, amplitude_scale={}",
            n,
            self.config.n_conformations,
            self.config.n_modes,
            self.config.amplitude_scale
        );

        // Step 1: Build Hessian and compute eigendecomposition
        let decomp = self.compute_anm_decomposition(ca_positions)?;

        // Step 2: Generate conformations by sampling mode amplitudes
        let mut conformations = Vec::with_capacity(self.config.n_conformations);
        let mut mode_amplitudes = Vec::with_capacity(self.config.n_conformations);

        // Boltzmann constant in kcal/(mol·K)
        let kb = 0.001987204;
        let kt = kb * self.config.temperature;

        for conf_idx in 0..self.config.n_conformations {
            let (new_coords, amplitudes) =
                self.sample_conformation(ca_positions, &decomp, kt)?;

            conformations.push(new_coords);
            mode_amplitudes.push(amplitudes);

            if (conf_idx + 1) % 20 == 0 {
                log::debug!("[ANM v2] Generated conformation {}/{}", conf_idx + 1, self.config.n_conformations);
            }
        }

        // Step 3: Compute ensemble statistics
        let (per_residue_rmsf, mean_rmsd, max_rmsd) =
            self.compute_ensemble_stats(ca_positions, &conformations);

        // v2: Compute per-residue variance (useful for cryptic scoring)
        let per_residue_variance = self.compute_per_residue_variance(ca_positions, &conformations);

        // Step 4: Identify dominant modes
        let dominant_modes = self.identify_dominant_modes(&mode_amplitudes, &decomp);

        log::info!(
            "[ANM v2] Ensemble generated: mean RMSD = {:.2}Å, max RMSD = {:.2}Å (target: ~3.5Å mean)",
            mean_rmsd,
            max_rmsd
        );

        Ok(AnmEnsembleV2 {
            original_coords: ca_positions.to_vec(),
            conformations,
            mode_amplitudes,
            per_residue_rmsf,
            mean_rmsd,
            max_rmsd,
            dominant_modes,
            per_residue_variance,
            config_snapshot: self.config.clone(),
        })
    }

    /// Compute ANM eigendecomposition (Hessian → eigenvalues + eigenvectors)
    fn compute_anm_decomposition(&self, ca_positions: &[[f32; 3]]) -> Result<AnmDecompositionV2> {
        let n = ca_positions.len();
        let n3 = 3 * n;
        let cutoff_sq = self.config.cutoff * self.config.cutoff;

        log::debug!("[ANM v2] Building {}×{} Hessian matrix", n3, n3);

        // Build 3N×3N Hessian matrix
        let mut hessian = DMatrix::zeros(n3, n3);
        let mut coordination = vec![0usize; n];

        for i in 0..n {
            for j in (i + 1)..n {
                let dx = (ca_positions[j][0] - ca_positions[i][0]) as f64;
                let dy = (ca_positions[j][1] - ca_positions[i][1]) as f64;
                let dz = (ca_positions[j][2] - ca_positions[i][2]) as f64;
                let dist_sq = dx * dx + dy * dy + dz * dz;

                if dist_sq < cutoff_sq && dist_sq > 1e-6 {
                    coordination[i] += 1;
                    coordination[j] += 1;

                    // Build 3×3 super-element: -γ/r² × (r ⊗ r)
                    let scale = -self.config.gamma / dist_sq;

                    let h_xx = scale * dx * dx;
                    let h_xy = scale * dx * dy;
                    let h_xz = scale * dx * dz;
                    let h_yy = scale * dy * dy;
                    let h_yz = scale * dy * dz;
                    let h_zz = scale * dz * dz;

                    let i3 = 3 * i;
                    let j3 = 3 * j;

                    // Off-diagonal block (i,j)
                    hessian[(i3, j3)] = h_xx;
                    hessian[(i3, j3 + 1)] = h_xy;
                    hessian[(i3, j3 + 2)] = h_xz;
                    hessian[(i3 + 1, j3)] = h_xy;
                    hessian[(i3 + 1, j3 + 1)] = h_yy;
                    hessian[(i3 + 1, j3 + 2)] = h_yz;
                    hessian[(i3 + 2, j3)] = h_xz;
                    hessian[(i3 + 2, j3 + 1)] = h_yz;
                    hessian[(i3 + 2, j3 + 2)] = h_zz;

                    // Off-diagonal block (j,i) - symmetric
                    hessian[(j3, i3)] = h_xx;
                    hessian[(j3, i3 + 1)] = h_xy;
                    hessian[(j3, i3 + 2)] = h_xz;
                    hessian[(j3 + 1, i3)] = h_xy;
                    hessian[(j3 + 1, i3 + 1)] = h_yy;
                    hessian[(j3 + 1, i3 + 2)] = h_yz;
                    hessian[(j3 + 2, i3)] = h_xz;
                    hessian[(j3 + 2, i3 + 1)] = h_yz;
                    hessian[(j3 + 2, i3 + 2)] = h_zz;

                    // Diagonal blocks: subtract
                    hessian[(i3, i3)] -= h_xx;
                    hessian[(i3, i3 + 1)] -= h_xy;
                    hessian[(i3, i3 + 2)] -= h_xz;
                    hessian[(i3 + 1, i3)] -= h_xy;
                    hessian[(i3 + 1, i3 + 1)] -= h_yy;
                    hessian[(i3 + 1, i3 + 2)] -= h_yz;
                    hessian[(i3 + 2, i3)] -= h_xz;
                    hessian[(i3 + 2, i3 + 1)] -= h_yz;
                    hessian[(i3 + 2, i3 + 2)] -= h_zz;

                    hessian[(j3, j3)] -= h_xx;
                    hessian[(j3, j3 + 1)] -= h_xy;
                    hessian[(j3, j3 + 2)] -= h_xz;
                    hessian[(j3 + 1, j3)] -= h_xy;
                    hessian[(j3 + 1, j3 + 1)] -= h_yy;
                    hessian[(j3 + 1, j3 + 2)] -= h_yz;
                    hessian[(j3 + 2, j3)] -= h_xz;
                    hessian[(j3 + 2, j3 + 1)] -= h_yz;
                    hessian[(j3 + 2, j3 + 2)] -= h_zz;
                }
            }
        }

        log::debug!("[ANM v2] Computing eigendecomposition...");

        // Eigendecomposition
        let eigen = SymmetricEigen::new(hessian);
        let eigenvalues: Vec<f64> = eigen.eigenvalues.iter().cloned().collect();
        let eigenvectors = eigen.eigenvectors;

        // Sort eigenvalues and get valid mode indices
        let mut indexed_eigenvalues: Vec<(usize, f64)> = eigenvalues
            .iter()
            .enumerate()
            .map(|(i, &v)| (i, v))
            .collect();
        indexed_eigenvalues.sort_by(|a, b| a.1.partial_cmp(&b.1).unwrap_or(std::cmp::Ordering::Equal));

        // Skip first 6 modes (rigid-body: 3 translations + 3 rotations)
        // Only keep modes with positive eigenvalues
        let valid_mode_indices: Vec<usize> = indexed_eigenvalues
            .iter()
            .skip(6)
            .filter(|(_, lambda)| *lambda > 1e-6)
            .take(self.config.n_modes)
            .map(|(idx, _)| *idx)
            .collect();

        log::debug!(
            "[ANM v2] Found {} valid modes (requested {})",
            valid_mode_indices.len(),
            self.config.n_modes
        );

        Ok(AnmDecompositionV2 {
            n_residues: n,
            eigenvalues,
            eigenvectors,
            coordination,
            valid_mode_indices,
        })
    }

    /// Sample a single conformation by displacing along normal modes
    fn sample_conformation(
        &mut self,
        ca_positions: &[[f32; 3]],
        decomp: &AnmDecompositionV2,
        kt: f64,
    ) -> Result<(Vec<[f32; 3]>, Vec<f64>)> {
        let n = ca_positions.len();
        let mut new_coords = ca_positions.to_vec();
        let mut amplitudes = Vec::with_capacity(decomp.valid_mode_indices.len());

        // Sample amplitude for each mode and apply displacement
        for &mode_idx in &decomp.valid_mode_indices {
            let lambda = decomp.eigenvalues[mode_idx];

            // Thermal amplitude: σ = sqrt(kT/λ) * amplitude_scale
            let sigma = (kt / lambda).sqrt() * self.config.amplitude_scale;

            // Sample from Gaussian
            let normal = Normal::new(0.0, sigma).map_err(|e| anyhow!("Invalid normal dist: {}", e))?;
            let amplitude: f64 = self.rng.sample(normal);
            amplitudes.push(amplitude);

            // Apply displacement along this mode
            let eigenvec = decomp.eigenvectors.column(mode_idx);
            for i in 0..n {
                let dx = (amplitude * eigenvec[3 * i]) as f32;
                let dy = (amplitude * eigenvec[3 * i + 1]) as f32;
                let dz = (amplitude * eigenvec[3 * i + 2]) as f32;

                new_coords[i][0] += dx;
                new_coords[i][1] += dy;
                new_coords[i][2] += dz;
            }
        }

        // Enforce maximum displacement constraint
        let mut any_clamped = false;
        for i in 0..n {
            let dx = new_coords[i][0] - ca_positions[i][0];
            let dy = new_coords[i][1] - ca_positions[i][1];
            let dz = new_coords[i][2] - ca_positions[i][2];
            let disp = (dx * dx + dy * dy + dz * dz).sqrt();

            if disp > self.config.max_displacement as f32 {
                let scale = self.config.max_displacement as f32 / disp;
                new_coords[i][0] = ca_positions[i][0] + dx * scale;
                new_coords[i][1] = ca_positions[i][1] + dy * scale;
                new_coords[i][2] = ca_positions[i][2] + dz * scale;
                any_clamped = true;
            }
        }

        if any_clamped {
            log::trace!("[ANM v2] Clamped some displacements to max {:.1}Å", self.config.max_displacement);
        }

        Ok((new_coords, amplitudes))
    }

    /// Compute ensemble statistics
    fn compute_ensemble_stats(
        &self,
        original: &[[f32; 3]],
        conformations: &[Vec<[f32; 3]>],
    ) -> (Vec<f64>, f64, f64) {
        let n = original.len();
        let n_conf = conformations.len();

        // Per-residue RMSF
        let mut rmsf = vec![0.0f64; n];
        for conf in conformations {
            for i in 0..n {
                let dx = (conf[i][0] - original[i][0]) as f64;
                let dy = (conf[i][1] - original[i][1]) as f64;
                let dz = (conf[i][2] - original[i][2]) as f64;
                rmsf[i] += dx * dx + dy * dy + dz * dz;
            }
        }
        for r in &mut rmsf {
            *r = (*r / n_conf as f64).sqrt();
        }

        // Global RMSD per conformation
        let mut rmsds = Vec::with_capacity(n_conf);
        for conf in conformations {
            let mut sum_sq = 0.0f64;
            for i in 0..n {
                let dx = (conf[i][0] - original[i][0]) as f64;
                let dy = (conf[i][1] - original[i][1]) as f64;
                let dz = (conf[i][2] - original[i][2]) as f64;
                sum_sq += dx * dx + dy * dy + dz * dz;
            }
            rmsds.push((sum_sq / n as f64).sqrt());
        }

        let mean_rmsd = rmsds.iter().sum::<f64>() / n_conf as f64;
        let max_rmsd = rmsds.iter().cloned().fold(0.0f64, f64::max);

        (rmsf, mean_rmsd, max_rmsd)
    }

    /// v2: Compute per-residue variance across ensemble
    /// This is useful for cryptic site scoring - high variance indicates flexibility
    fn compute_per_residue_variance(
        &self,
        original: &[[f32; 3]],
        conformations: &[Vec<[f32; 3]>],
    ) -> Vec<f64> {
        let n = original.len();
        let n_conf = conformations.len();

        let mut variance = vec![0.0f64; n];

        // First compute mean position for each residue
        let mut mean_positions = vec![[0.0f64; 3]; n];
        for conf in conformations {
            for i in 0..n {
                mean_positions[i][0] += conf[i][0] as f64;
                mean_positions[i][1] += conf[i][1] as f64;
                mean_positions[i][2] += conf[i][2] as f64;
            }
        }
        for i in 0..n {
            mean_positions[i][0] /= n_conf as f64;
            mean_positions[i][1] /= n_conf as f64;
            mean_positions[i][2] /= n_conf as f64;
        }

        // Compute variance from mean
        for conf in conformations {
            for i in 0..n {
                let dx = conf[i][0] as f64 - mean_positions[i][0];
                let dy = conf[i][1] as f64 - mean_positions[i][1];
                let dz = conf[i][2] as f64 - mean_positions[i][2];
                variance[i] += dx * dx + dy * dy + dz * dz;
            }
        }

        // Normalize
        for v in &mut variance {
            *v /= n_conf as f64;
        }

        variance
    }

    /// Identify which modes contributed most to conformational variance
    fn identify_dominant_modes(
        &self,
        mode_amplitudes: &[Vec<f64>],
        decomp: &AnmDecompositionV2,
    ) -> Vec<usize> {
        if mode_amplitudes.is_empty() || mode_amplitudes[0].is_empty() {
            return vec![];
        }

        let n_modes = mode_amplitudes[0].len();
        let n_conf = mode_amplitudes.len();

        // Compute variance of each mode's amplitude across conformations
        let mut mode_variances: Vec<(usize, f64)> = (0..n_modes)
            .map(|m| {
                let mean: f64 = mode_amplitudes.iter().map(|a| a[m]).sum::<f64>() / n_conf as f64;
                let variance: f64 = mode_amplitudes
                    .iter()
                    .map(|a| (a[m] - mean).powi(2))
                    .sum::<f64>()
                    / n_conf as f64;
                (m, variance)
            })
            .collect();

        // Sort by variance (descending) and return top modes
        mode_variances.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        mode_variances
            .iter()
            .take(5)
            .filter_map(|(idx, _)| decomp.valid_mode_indices.get(*idx).copied())
            .collect()
    }
}

impl AnmEnsembleV2 {
    /// Export ensemble as multi-model PDB string
    pub fn to_pdb_string(&self, chain_id: char) -> String {
        let mut pdb = String::new();

        // Write original as MODEL 0
        pdb.push_str("MODEL        0\n");
        for (i, coord) in self.original_coords.iter().enumerate() {
            pdb.push_str(&format!(
                "ATOM  {:5}  CA  ALA {}{:4}    {:8.3}{:8.3}{:8.3}  1.00  0.00           C\n",
                i + 1,
                chain_id,
                i + 1,
                coord[0],
                coord[1],
                coord[2]
            ));
        }
        pdb.push_str("ENDMDL\n");

        // Write each conformation as a separate MODEL
        for (model_idx, conf) in self.conformations.iter().enumerate() {
            pdb.push_str(&format!("MODEL     {:4}\n", model_idx + 1));
            for (i, coord) in conf.iter().enumerate() {
                pdb.push_str(&format!(
                    "ATOM  {:5}  CA  ALA {}{:4}    {:8.3}{:8.3}{:8.3}  1.00  0.00           C\n",
                    i + 1,
                    chain_id,
                    i + 1,
                    coord[0],
                    coord[1],
                    coord[2]
                ));
            }
            pdb.push_str("ENDMDL\n");
        }

        pdb.push_str("END\n");
        pdb
    }

    /// Get residue indices that have high RMSF (most flexible)
    pub fn get_flexible_residues(&self, threshold: f64) -> Vec<usize> {
        self.per_residue_rmsf
            .iter()
            .enumerate()
            .filter(|(_, &rmsf)| rmsf >= threshold)
            .map(|(i, _)| i)
            .collect()
    }

    /// v2: Get residue indices with high variance (potential cryptic sites)
    pub fn get_high_variance_residues(&self, percentile: f64) -> Vec<usize> {
        let mut sorted_variance: Vec<(usize, f64)> = self.per_residue_variance
            .iter()
            .enumerate()
            .map(|(i, &v)| (i, v))
            .collect();
        sorted_variance.sort_by(|a, b| b.1.partial_cmp(&a.1).unwrap_or(std::cmp::Ordering::Equal));

        let cutoff_idx = ((1.0 - percentile) * sorted_variance.len() as f64) as usize;
        sorted_variance[..cutoff_idx.max(1)]
            .iter()
            .map(|(i, _)| *i)
            .collect()
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    fn make_simple_helix(n: usize) -> Vec<[f32; 3]> {
        // Simple alpha helix geometry (rise 1.5Å, radius 2.3Å, 3.6 residues/turn)
        let rise = 1.5f32;
        let radius = 2.3f32;
        let residues_per_turn = 3.6f32;

        (0..n)
            .map(|i| {
                let angle = 2.0 * std::f32::consts::PI * i as f32 / residues_per_turn;
                [
                    radius * angle.cos(),
                    radius * angle.sin(),
                    rise * i as f32,
                ]
            })
            .collect()
    }

    #[test]
    fn test_anm_v2_decomposition() {
        let coords = make_simple_helix(20);
        let config = AnmEnsembleConfigV2 {
            n_conformations: 5,
            n_modes: 10,
            ..Default::default()
        };

        let mut gen = AnmEnsembleGeneratorV2::new(config);
        let decomp = gen.compute_anm_decomposition(&coords).unwrap();

        assert_eq!(decomp.n_residues, 20);
        assert_eq!(decomp.eigenvalues.len(), 60); // 3N
        assert!(decomp.valid_mode_indices.len() <= 10);
    }

    #[test]
    fn test_anm_v2_ensemble_generation() {
        let coords = make_simple_helix(30);
        let config = AnmEnsembleConfigV2 {
            n_conformations: 10,
            n_modes: 5,
            amplitude_scale: 5.0,  // v2 default
            seed: Some(42), // Reproducible
            ..Default::default()
        };

        let mut gen = AnmEnsembleGeneratorV2::new(config);
        let ensemble = gen.generate_ensemble(&coords).unwrap();

        assert_eq!(ensemble.original_coords.len(), 30);
        assert_eq!(ensemble.conformations.len(), 10);
        assert!(ensemble.mean_rmsd > 0.0);
        // v2 should have larger RMSD than v1
        assert!(ensemble.mean_rmsd > 1.0, "v2 mean RMSD should be > 1.0Å, got {:.2}Å", ensemble.mean_rmsd);
    }

    #[test]
    fn test_anm_v2_max_displacement_constraint() {
        let coords = make_simple_helix(20);
        let config = AnmEnsembleConfigV2 {
            n_conformations: 5,
            n_modes: 10,
            amplitude_scale: 10.0, // Very large amplitudes
            max_displacement: 8.0, // v2 default
            seed: Some(123),
            ..Default::default()
        };

        let mut gen = AnmEnsembleGeneratorV2::new(config);
        let ensemble = gen.generate_ensemble(&coords).unwrap();

        // Check that no residue moved more than max_displacement
        for conf in &ensemble.conformations {
            for (i, (orig, new)) in coords.iter().zip(conf.iter()).enumerate() {
                let dx = new[0] - orig[0];
                let dy = new[1] - orig[1];
                let dz = new[2] - orig[2];
                let disp = (dx * dx + dy * dy + dz * dz).sqrt();
                assert!(
                    disp <= 8.1, // Allow small tolerance
                    "Residue {} moved {:.2}Å, exceeds max 8.0Å",
                    i,
                    disp
                );
            }
        }
    }

    #[test]
    fn test_anm_v2_variance_computation() {
        let coords = make_simple_helix(20);
        let config = AnmEnsembleConfigV2 {
            n_conformations: 20,
            seed: Some(42),
            ..Default::default()
        };

        let mut gen = AnmEnsembleGeneratorV2::new(config);
        let ensemble = gen.generate_ensemble(&coords).unwrap();

        // Variance should be computed
        assert_eq!(ensemble.per_residue_variance.len(), 20);

        // All variances should be non-negative
        for v in &ensemble.per_residue_variance {
            assert!(*v >= 0.0);
        }

        // High variance residues should return some residues
        let high_var = ensemble.get_high_variance_residues(0.9);
        assert!(!high_var.is_empty());
    }

    #[test]
    fn test_v2_vs_v1_rmsd_increase() {
        let coords = make_simple_helix(50);

        // v1-compatible settings
        let mut gen_v1 = AnmEnsembleGeneratorV2::v1_compatible();
        let ensemble_v1 = gen_v1.generate_ensemble(&coords).unwrap();

        // v2 default settings
        let mut gen_v2 = AnmEnsembleGeneratorV2::default_config();
        let ensemble_v2 = gen_v2.generate_ensemble(&coords).unwrap();

        // v2 should have larger RMSD due to increased amplitude_scale
        assert!(
            ensemble_v2.mean_rmsd > ensemble_v1.mean_rmsd,
            "v2 mean RMSD ({:.2}Å) should be > v1 ({:.2}Å)",
            ensemble_v2.mean_rmsd,
            ensemble_v1.mean_rmsd
        );
    }
}
