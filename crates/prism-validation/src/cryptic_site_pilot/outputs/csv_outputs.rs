//! CSV Output Generators for Cryptic Site Pilot
//!
//! Produces data files for downstream analysis:
//! - RMSF per residue
//! - Contact residue lists for docking
//! - Volume time series

use std::io::Write;

/// Write RMSF per residue to CSV
///
/// # Arguments
/// * `writer` - Output writer
/// * `residue_ids` - Residue sequence numbers
/// * `residue_names` - 3-letter residue codes
/// * `chain_ids` - Chain identifiers
/// * `rmsf_values` - RMSF values in Angstroms
/// * `bfactors` - Original B-factors (optional, for comparison)
pub fn write_rmsf_csv<W: Write>(
    writer: &mut W,
    residue_ids: &[i32],
    residue_names: &[String],
    chain_ids: &[char],
    rmsf_values: &[f64],
    bfactors: Option<&[f64]>,
) -> std::io::Result<()> {
    // Header
    if bfactors.is_some() {
        writeln!(writer, "chain,residue_id,residue_name,rmsf_angstrom,bfactor,flexibility_class")?;
    } else {
        writeln!(writer, "chain,residue_id,residue_name,rmsf_angstrom,flexibility_class")?;
    }

    // Compute global statistics for classification
    let mean_rmsf = rmsf_values.iter().sum::<f64>() / rmsf_values.len() as f64;

    for i in 0..residue_ids.len() {
        let res_id = residue_ids[i];
        let res_name = residue_names.get(i).map(|s| s.as_str()).unwrap_or("UNK");
        let chain = chain_ids.get(i).copied().unwrap_or('A');
        let rmsf = rmsf_values.get(i).copied().unwrap_or(0.0);

        // Classify flexibility relative to mean
        let flex_class = if rmsf < mean_rmsf * 0.5 {
            "rigid"
        } else if rmsf < mean_rmsf * 1.0 {
            "moderate"
        } else if rmsf < mean_rmsf * 1.5 {
            "flexible"
        } else {
            "highly_flexible"
        };

        if let Some(bf) = bfactors {
            let bfactor = bf.get(i).copied().unwrap_or(0.0);
            writeln!(writer, "{},{},{},{:.4},{:.2},{}", chain, res_id, res_name, rmsf, bfactor, flex_class)?;
        } else {
            writeln!(writer, "{},{},{},{:.4},{}", chain, res_id, res_name, rmsf, flex_class)?;
        }
    }

    Ok(())
}

/// Contact definition for a binding site
#[derive(Debug, Clone)]
pub struct ContactResidue {
    /// Residue sequence number
    pub residue_id: i32,
    /// 3-letter residue code
    pub residue_name: String,
    /// Chain identifier
    pub chain_id: char,
    /// Distance to pocket centroid (Å)
    pub distance_to_centroid: f64,
    /// Whether this residue lines the pocket surface
    pub is_surface: bool,
    /// SASA when pocket is open (Å²)
    pub sasa_open: f64,
    /// SASA when pocket is closed (Å²)
    pub sasa_closed: f64,
    /// Number of frames where this residue contacts the pocket
    pub contact_frequency: f64,
    /// Hydrophobicity score
    pub hydrophobicity: f64,
    /// Is hydrogen bond donor
    pub is_donor: bool,
    /// Is hydrogen bond acceptor
    pub is_acceptor: bool,
}

/// Write contact residues to CSV for docking preparation
///
/// This file defines the binding site for molecular docking software like:
/// - AutoDock Vina
/// - GOLD
/// - Glide
pub fn write_contacts_csv<W: Write>(
    writer: &mut W,
    site_id: &str,
    contacts: &[ContactResidue],
) -> std::io::Result<()> {
    writeln!(writer, "# Binding site definition for docking")?;
    writeln!(writer, "# Site: {}", site_id)?;
    writeln!(writer, "# Total contact residues: {}", contacts.len())?;
    writeln!(writer, "#")?;
    writeln!(writer, "chain,residue_id,residue_name,distance_angstrom,is_surface,sasa_open,sasa_closed,contact_freq,hydrophobicity,is_donor,is_acceptor")?;

    for contact in contacts {
        writeln!(
            writer,
            "{},{},{},{:.2},{},{:.1},{:.1},{:.3},{:.3},{},{}",
            contact.chain_id,
            contact.residue_id,
            contact.residue_name,
            contact.distance_to_centroid,
            if contact.is_surface { "true" } else { "false" },
            contact.sasa_open,
            contact.sasa_closed,
            contact.contact_frequency,
            contact.hydrophobicity,
            if contact.is_donor { "true" } else { "false" },
            if contact.is_acceptor { "true" } else { "false" },
        )?;
    }

    Ok(())
}

/// Generate PyMOL selection command for contacts
pub fn generate_pymol_selection(site_id: &str, contacts: &[ContactResidue]) -> String {
    if contacts.is_empty() {
        return format!("# No contacts for site {}\n", site_id);
    }

    let mut script = String::new();
    script.push_str(&format!("# PyMOL selection for {}\n", site_id));
    script.push_str(&format!("# Generated by PRISM-4D\n\n"));

    // Group residues by chain
    let mut by_chain: std::collections::HashMap<char, Vec<i32>> = std::collections::HashMap::new();
    for contact in contacts {
        by_chain.entry(contact.chain_id).or_default().push(contact.residue_id);
    }

    // Build selection
    let mut selections = Vec::new();
    for (chain, residues) in by_chain {
        let resi_list = residues.iter()
            .map(|r| r.to_string())
            .collect::<Vec<_>>()
            .join("+");
        selections.push(format!("(chain {} and resi {})", chain, resi_list));
    }

    let selection_str = selections.join(" or ");
    script.push_str(&format!("select {}_site, {}\n", site_id.replace(" ", "_").to_lowercase(), selection_str));
    script.push_str(&format!("show sticks, {}_site\n", site_id.replace(" ", "_").to_lowercase()));
    script.push_str(&format!("color yellow, {}_site\n", site_id.replace(" ", "_").to_lowercase()));

    script
}

/// Write RMSF heatmap data (for plotting)
///
/// Outputs in format suitable for seaborn/matplotlib heatmaps
pub fn write_rmsf_heatmap_data<W: Write>(
    writer: &mut W,
    residue_ids: &[i32],
    secondary_structure: Option<&[char]>, // H=helix, E=sheet, C=coil
    rmsf_values: &[f64],
) -> std::io::Result<()> {
    writeln!(writer, "residue_id,secondary_structure,rmsf,rmsf_normalized")?;

    // Normalize RMSF to 0-1
    let max_rmsf = rmsf_values.iter().cloned().fold(0.0f64, f64::max);
    let min_rmsf = rmsf_values.iter().cloned().fold(f64::INFINITY, f64::min);
    let range = (max_rmsf - min_rmsf).max(0.01);

    for (i, &res_id) in residue_ids.iter().enumerate() {
        let rmsf = rmsf_values.get(i).copied().unwrap_or(0.0);
        let ss = secondary_structure.and_then(|s| s.get(i).copied()).unwrap_or('C');
        let normalized = (rmsf - min_rmsf) / range;

        writeln!(writer, "{},{},{:.4},{:.4}", res_id, ss, rmsf, normalized)?;
    }

    Ok(())
}

/// Extract contact residues from pocket detection results
///
/// # Arguments
/// * `pocket_centroid` - [x, y, z] of pocket center
/// * `residue_coords` - Per-residue coordinates (e.g., Cα positions)
/// * `residue_ids` - Residue sequence numbers
/// * `residue_names` - 3-letter codes
/// * `chain_ids` - Chain identifiers
/// * `cutoff_distance` - Maximum distance from centroid to be considered a contact
pub fn extract_contacts(
    pocket_centroid: [f64; 3],
    residue_coords: &[[f64; 3]],
    residue_ids: &[i32],
    residue_names: &[String],
    chain_ids: &[char],
    cutoff_distance: f64,
) -> Vec<ContactResidue> {
    let hydrophobic_set: std::collections::HashSet<&str> =
        ["ILE", "VAL", "LEU", "PHE", "MET", "ALA", "TRP", "PRO"]
        .iter().cloned().collect();

    let donor_set: std::collections::HashSet<&str> =
        ["ARG", "LYS", "ASN", "GLN", "HIS", "SER", "THR", "TYR", "TRP"]
        .iter().cloned().collect();

    let acceptor_set: std::collections::HashSet<&str> =
        ["ASP", "GLU", "ASN", "GLN", "HIS", "SER", "THR", "TYR"]
        .iter().cloned().collect();

    let mut contacts = Vec::new();

    for i in 0..residue_coords.len() {
        let coord = residue_coords[i];
        let dx = coord[0] - pocket_centroid[0];
        let dy = coord[1] - pocket_centroid[1];
        let dz = coord[2] - pocket_centroid[2];
        let distance = (dx * dx + dy * dy + dz * dz).sqrt();

        if distance <= cutoff_distance {
            let res_name = residue_names.get(i).cloned().unwrap_or_else(|| "UNK".to_string());
            let res_upper = res_name.to_uppercase();

            let hydrophobicity = match res_upper.as_str() {
                "ILE" => 1.0, "VAL" => 0.97, "LEU" => 0.92, "PHE" => 0.81,
                "MET" => 0.71, "ALA" => 0.70, "TRP" => 0.40, "PRO" => 0.32,
                _ => 0.3,
            };

            contacts.push(ContactResidue {
                residue_id: residue_ids.get(i).copied().unwrap_or(i as i32 + 1),
                residue_name: res_name,
                chain_id: chain_ids.get(i).copied().unwrap_or('A'),
                distance_to_centroid: distance,
                is_surface: distance <= cutoff_distance * 0.7,
                sasa_open: 0.0,  // To be filled by caller
                sasa_closed: 0.0,
                contact_frequency: 1.0,
                hydrophobicity,
                is_donor: donor_set.contains(res_upper.as_str()),
                is_acceptor: acceptor_set.contains(res_upper.as_str()),
            });
        }
    }

    // Sort by distance
    contacts.sort_by(|a, b| a.distance_to_centroid.partial_cmp(&b.distance_to_centroid)
        .unwrap_or(std::cmp::Ordering::Equal));

    contacts
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_write_rmsf_csv() {
        let residue_ids = vec![1, 2, 3, 4, 5];
        let residue_names: Vec<String> = vec!["ALA", "GLY", "LEU", "ASP", "PHE"]
            .into_iter().map(String::from).collect();
        let chain_ids = vec!['A'; 5];
        let rmsf_values = vec![0.5, 1.0, 2.0, 0.8, 1.5];

        let mut output = Vec::new();
        write_rmsf_csv(&mut output, &residue_ids, &residue_names, &chain_ids, &rmsf_values, None).unwrap();

        let csv = String::from_utf8(output).unwrap();
        assert!(csv.contains("chain,residue_id"));
        assert!(csv.contains("A,1,ALA"));
        assert!(csv.contains("0.5000"));
    }

    #[test]
    fn test_write_contacts_csv() {
        let contacts = vec![
            ContactResidue {
                residue_id: 165,
                residue_name: "LEU".to_string(),
                chain_id: 'A',
                distance_to_centroid: 5.5,
                is_surface: true,
                sasa_open: 120.0,
                sasa_closed: 20.0,
                contact_frequency: 0.85,
                hydrophobicity: 0.92,
                is_donor: false,
                is_acceptor: false,
            },
            ContactResidue {
                residue_id: 166,
                residue_name: "SER".to_string(),
                chain_id: 'A',
                distance_to_centroid: 6.2,
                is_surface: true,
                sasa_open: 80.0,
                sasa_closed: 40.0,
                contact_frequency: 0.72,
                hydrophobicity: 0.41,
                is_donor: true,
                is_acceptor: true,
            },
        ];

        let mut output = Vec::new();
        write_contacts_csv(&mut output, "Omega loop", &contacts).unwrap();

        let csv = String::from_utf8(output).unwrap();
        assert!(csv.contains("Site: Omega loop"));
        assert!(csv.contains("165,LEU"));
        assert!(csv.contains("166,SER"));
    }

    #[test]
    fn test_pymol_selection() {
        let contacts = vec![
            ContactResidue {
                residue_id: 100,
                residue_name: "ALA".to_string(),
                chain_id: 'A',
                distance_to_centroid: 5.0,
                is_surface: true,
                sasa_open: 0.0,
                sasa_closed: 0.0,
                contact_frequency: 1.0,
                hydrophobicity: 0.7,
                is_donor: false,
                is_acceptor: false,
            },
            ContactResidue {
                residue_id: 105,
                residue_name: "LEU".to_string(),
                chain_id: 'A',
                distance_to_centroid: 6.0,
                is_surface: true,
                sasa_open: 0.0,
                sasa_closed: 0.0,
                contact_frequency: 1.0,
                hydrophobicity: 0.92,
                is_donor: false,
                is_acceptor: false,
            },
        ];

        let script = generate_pymol_selection("test site", &contacts);
        assert!(script.contains("select test_site_site"));
        assert!(script.contains("resi 100+105"));
    }

    #[test]
    fn test_extract_contacts() {
        let centroid = [10.0, 10.0, 10.0];
        let coords = vec![
            [10.0, 10.0, 10.0],  // Distance 0 - definitely contact
            [12.0, 10.0, 10.0],  // Distance 2 - contact
            [20.0, 10.0, 10.0],  // Distance 10 - outside
        ];
        let residue_ids = vec![1, 2, 3];
        let residue_names = vec!["ALA".to_string(), "GLY".to_string(), "LEU".to_string()];
        let chain_ids = vec!['A', 'A', 'A'];

        let contacts = extract_contacts(centroid, &coords, &residue_ids, &residue_names, &chain_ids, 8.0);

        assert_eq!(contacts.len(), 2);
        assert_eq!(contacts[0].residue_id, 1);
        assert_eq!(contacts[1].residue_id, 2);
    }
}
