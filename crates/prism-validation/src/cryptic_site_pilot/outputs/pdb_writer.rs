//! Multi-MODEL PDB Trajectory Writer
//!
//! Writes conformational ensembles as multi-MODEL PDB files compatible with:
//! - PyMOL
//! - VMD
//! - ChimeraX
//! - UCSF Chimera
//!
//! # Format
//!
//! ```text
//! MODEL        1
//! ATOM      1  N   ALA A   1      ...
//! ATOM      2  CA  ALA A   1      ...
//! ...
//! ENDMDL
//! MODEL        2
//! ...
//! ENDMDL
//! END
//! ```

use std::io::Write;

/// Writes multi-MODEL PDB files from coordinate ensembles
pub struct MultiModelPdbWriter {
    /// Title for the trajectory
    pub title: String,
    /// Whether to include CONECT records
    pub include_conect: bool,
    /// Whether to include B-factors from RMSF
    pub rmsf_as_bfactor: bool,
    /// Atom names for output
    atom_names: Vec<String>,
    /// Residue names
    residue_names: Vec<String>,
    /// Residue sequence numbers
    residue_seqs: Vec<i32>,
    /// Chain IDs
    chain_ids: Vec<char>,
    /// Element symbols
    elements: Vec<String>,
}

impl MultiModelPdbWriter {
    /// Create a new PDB writer
    pub fn new(title: &str) -> Self {
        Self {
            title: title.to_string(),
            include_conect: false,
            rmsf_as_bfactor: true,
            atom_names: Vec::new(),
            residue_names: Vec::new(),
            residue_seqs: Vec::new(),
            chain_ids: Vec::new(),
            elements: Vec::new(),
        }
    }

    /// Set atom metadata from template structure
    ///
    /// # Arguments
    /// * `atom_names` - Atom names (e.g., "CA", "N", "C")
    /// * `residue_names` - 3-letter residue codes (e.g., "ALA", "GLY")
    /// * `residue_seqs` - Residue sequence numbers
    /// * `chain_ids` - Chain identifiers
    /// * `elements` - Element symbols (e.g., "C", "N", "O")
    pub fn set_metadata(
        &mut self,
        atom_names: Vec<String>,
        residue_names: Vec<String>,
        residue_seqs: Vec<i32>,
        chain_ids: Vec<char>,
        elements: Vec<String>,
    ) {
        self.atom_names = atom_names;
        self.residue_names = residue_names;
        self.residue_seqs = residue_seqs;
        self.chain_ids = chain_ids;
        self.elements = elements;
    }

    /// Set metadata for CÎ±-only trajectory
    ///
    /// # Arguments
    /// * `residue_names` - 3-letter residue codes
    /// * `chain_id` - Single chain ID for all residues
    pub fn set_ca_metadata(&mut self, residue_names: Vec<String>, chain_id: char) {
        let n = residue_names.len();
        self.atom_names = vec!["CA".to_string(); n];
        self.residue_names = residue_names;
        self.residue_seqs = (1..=n as i32).collect();
        self.chain_ids = vec![chain_id; n];
        self.elements = vec!["C".to_string(); n];
    }

    /// Write ensemble to PDB file
    ///
    /// # Arguments
    /// * `conformations` - Coordinates per model: [n_models][n_atoms][3]
    /// * `writer` - Output writer (file or buffer)
    /// * `bfactors` - Optional per-atom B-factors (e.g., RMSF values)
    pub fn write<W: Write>(
        &self,
        conformations: &[Vec<[f32; 3]>],
        writer: &mut W,
        bfactors: Option<&[f64]>,
    ) -> std::io::Result<()> {
        // Write header
        writeln!(writer, "TITLE     {}", self.title)?;
        writeln!(writer, "REMARK   Generated by PRISM-4D Cryptic Site Pilot")?;
        writeln!(writer, "REMARK   {} models, {} atoms per model",
            conformations.len(),
            conformations.first().map(|c| c.len()).unwrap_or(0)
        )?;

        // Write each model
        for (model_idx, coords) in conformations.iter().enumerate() {
            writeln!(writer, "MODEL     {:4}", model_idx + 1)?;

            for (atom_idx, coord) in coords.iter().enumerate() {
                let atom_name = self.atom_names.get(atom_idx)
                    .map(|s| s.as_str())
                    .unwrap_or("CA");
                let res_name = self.residue_names.get(atom_idx)
                    .map(|s| s.as_str())
                    .unwrap_or("UNK");
                let res_seq = self.residue_seqs.get(atom_idx)
                    .copied()
                    .unwrap_or((atom_idx + 1) as i32);
                let chain_id = self.chain_ids.get(atom_idx)
                    .copied()
                    .unwrap_or('A');
                let element = self.elements.get(atom_idx)
                    .map(|s| s.as_str())
                    .unwrap_or("C");

                // Use RMSF as B-factor if available
                let bfactor = if self.rmsf_as_bfactor {
                    bfactors.and_then(|b| b.get(atom_idx).copied())
                        .unwrap_or(20.0)
                } else {
                    20.0
                };

                self.write_atom_line(
                    writer,
                    atom_idx + 1,
                    atom_name,
                    res_name,
                    chain_id,
                    res_seq,
                    coord[0] as f64,
                    coord[1] as f64,
                    coord[2] as f64,
                    1.0, // Occupancy
                    bfactor,
                    element,
                )?;
            }

            writeln!(writer, "ENDMDL")?;
        }

        writeln!(writer, "END")?;
        Ok(())
    }

    /// Write a single ATOM line in PDB format
    fn write_atom_line<W: Write>(
        &self,
        writer: &mut W,
        serial: usize,
        atom_name: &str,
        res_name: &str,
        chain_id: char,
        res_seq: i32,
        x: f64,
        y: f64,
        z: f64,
        occupancy: f64,
        bfactor: f64,
        element: &str,
    ) -> std::io::Result<()> {
        // PDB format columns (fixed width):
        // ATOM      1  CA  ALA A   1      10.000  20.000  30.000  1.00 20.00           C
        // 1-6: ATOM
        // 7-11: serial (right-justified)
        // 13-16: atom name (left-justified for 2-char, centered for 3-4 char)
        // 17: altLoc
        // 18-20: resName
        // 22: chainID
        // 23-26: resSeq (right-justified)
        // 27: iCode
        // 31-38: x (8.3f)
        // 39-46: y (8.3f)
        // 47-54: z (8.3f)
        // 55-60: occupancy (6.2f)
        // 61-66: tempFactor (6.2f)
        // 77-78: element (right-justified)

        // Format atom name properly
        let formatted_atom = if atom_name.len() == 4 {
            atom_name.to_string()
        } else if atom_name.len() == 1 {
            format!(" {}  ", atom_name)
        } else if atom_name.len() == 2 {
            format!(" {} ", atom_name)
        } else {
            format!(" {}", atom_name)
        };

        writeln!(
            writer,
            "ATOM  {:5} {:4} {:3} {:1}{:4}    {:8.3}{:8.3}{:8.3}{:6.2}{:6.2}          {:>2}",
            serial % 100000,
            formatted_atom,
            res_name,
            chain_id,
            res_seq,
            x,
            y,
            z,
            occupancy,
            bfactor,
            element
        )
    }

    /// Write representative structures (top N by some criterion)
    ///
    /// # Arguments
    /// * `conformations` - All conformations
    /// * `frame_indices` - Which frames to include
    /// * `writer` - Output writer
    /// * `bfactors` - Optional B-factors
    pub fn write_selected<W: Write>(
        &self,
        conformations: &[Vec<[f32; 3]>],
        frame_indices: &[usize],
        writer: &mut W,
        bfactors: Option<&[f64]>,
    ) -> std::io::Result<()> {
        let selected: Vec<Vec<[f32; 3]>> = frame_indices.iter()
            .filter_map(|&idx| conformations.get(idx).cloned())
            .collect();

        self.write(&selected, writer, bfactors)
    }

    /// Write pocket-centered view
    ///
    /// Writes only atoms within a radius of the pocket centroid
    pub fn write_pocket_focused<W: Write>(
        &self,
        conformations: &[Vec<[f32; 3]>],
        pocket_centroid: [f64; 3],
        radius: f64,
        writer: &mut W,
    ) -> std::io::Result<()> {
        writeln!(writer, "TITLE     {} - Pocket Focus", self.title)?;
        writeln!(writer, "REMARK   Atoms within {:.1} A of pocket centroid", radius)?;
        writeln!(writer, "REMARK   Centroid: ({:.2}, {:.2}, {:.2})",
            pocket_centroid[0], pocket_centroid[1], pocket_centroid[2])?;

        let radius_sq = (radius * radius) as f32;

        for (model_idx, coords) in conformations.iter().enumerate() {
            writeln!(writer, "MODEL     {:4}", model_idx + 1)?;

            let mut written_serial = 0;

            for (atom_idx, coord) in coords.iter().enumerate() {
                // Check distance to centroid
                let dx = coord[0] - pocket_centroid[0] as f32;
                let dy = coord[1] - pocket_centroid[1] as f32;
                let dz = coord[2] - pocket_centroid[2] as f32;
                let dist_sq = dx * dx + dy * dy + dz * dz;

                if dist_sq <= radius_sq {
                    written_serial += 1;

                    let atom_name = self.atom_names.get(atom_idx)
                        .map(|s| s.as_str())
                        .unwrap_or("CA");
                    let res_name = self.residue_names.get(atom_idx)
                        .map(|s| s.as_str())
                        .unwrap_or("UNK");
                    let res_seq = self.residue_seqs.get(atom_idx)
                        .copied()
                        .unwrap_or((atom_idx + 1) as i32);
                    let chain_id = self.chain_ids.get(atom_idx)
                        .copied()
                        .unwrap_or('A');
                    let element = self.elements.get(atom_idx)
                        .map(|s| s.as_str())
                        .unwrap_or("C");

                    self.write_atom_line(
                        writer,
                        written_serial,
                        atom_name,
                        res_name,
                        chain_id,
                        res_seq,
                        coord[0] as f64,
                        coord[1] as f64,
                        coord[2] as f64,
                        1.0,
                        20.0,
                        element,
                    )?;
                }
            }

            writeln!(writer, "ENDMDL")?;
        }

        writeln!(writer, "END")?;
        Ok(())
    }
}

/// Helper to write a single structure (not multi-model)
pub fn write_single_structure<W: Write>(
    coords: &[[f32; 3]],
    residue_names: &[String],
    chain_id: char,
    writer: &mut W,
    bfactors: Option<&[f64]>,
) -> std::io::Result<()> {
    let mut pdb_writer = MultiModelPdbWriter::new("Single Structure");
    pdb_writer.set_ca_metadata(residue_names.to_vec(), chain_id);
    pdb_writer.write(&[coords.to_vec()], writer, bfactors)
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_write_single_model() {
        let mut writer = MultiModelPdbWriter::new("Test Structure");
        writer.set_ca_metadata(
            vec!["ALA".to_string(), "GLY".to_string(), "LEU".to_string()],
            'A',
        );

        let coords = vec![vec![
            [0.0, 0.0, 0.0],
            [3.8, 0.0, 0.0],
            [7.6, 0.0, 0.0],
        ]];

        let mut output = Vec::new();
        writer.write(&coords, &mut output, None).unwrap();

        let pdb_str = String::from_utf8(output).unwrap();
        assert!(pdb_str.contains("TITLE"));
        assert!(pdb_str.contains("MODEL"));
        assert!(pdb_str.contains("ATOM"));
        assert!(pdb_str.contains("ENDMDL"));
        assert!(pdb_str.contains("END"));
    }

    #[test]
    fn test_write_multi_model() {
        let mut writer = MultiModelPdbWriter::new("Multi-Model Test");
        writer.set_ca_metadata(vec!["ALA".to_string(); 5], 'A');

        let conformations: Vec<Vec<[f32; 3]>> = (0..3)
            .map(|m| {
                (0..5).map(|i| [
                    (i as f32) * 3.8 + (m as f32) * 0.1,
                    0.0,
                    0.0,
                ]).collect()
            })
            .collect();

        let mut output = Vec::new();
        writer.write(&conformations, &mut output, None).unwrap();

        let pdb_str = String::from_utf8(output).unwrap();

        // Count models
        let model_count = pdb_str.matches("MODEL").count();
        assert_eq!(model_count, 3);

        let endmdl_count = pdb_str.matches("ENDMDL").count();
        assert_eq!(endmdl_count, 3);
    }

    #[test]
    fn test_with_bfactors() {
        let mut writer = MultiModelPdbWriter::new("RMSF Test");
        writer.set_ca_metadata(vec!["ALA".to_string(); 3], 'A');
        writer.rmsf_as_bfactor = true;

        let coords = vec![vec![
            [0.0, 0.0, 0.0],
            [3.8, 0.0, 0.0],
            [7.6, 0.0, 0.0],
        ]];

        let bfactors = vec![1.5, 2.5, 0.8];

        let mut output = Vec::new();
        writer.write(&coords, &mut output, Some(&bfactors)).unwrap();

        let pdb_str = String::from_utf8(output).unwrap();
        // B-factors should appear in output
        assert!(pdb_str.contains("1.50") || pdb_str.contains("1.5"));
    }

    #[test]
    fn test_selected_frames() {
        let mut writer = MultiModelPdbWriter::new("Selected Frames");
        writer.set_ca_metadata(vec!["ALA".to_string(); 3], 'A');

        let conformations: Vec<Vec<[f32; 3]>> = (0..10)
            .map(|_| vec![[0.0, 0.0, 0.0]; 3])
            .collect();

        let selected_indices = vec![0, 5, 9];

        let mut output = Vec::new();
        writer.write_selected(&conformations, &selected_indices, &mut output, None).unwrap();

        let pdb_str = String::from_utf8(output).unwrap();
        let model_count = pdb_str.matches("MODEL").count();
        assert_eq!(model_count, 3);
    }
}
