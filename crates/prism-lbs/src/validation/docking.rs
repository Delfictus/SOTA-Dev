//! Docking Site Generator Module
//!
//! Generates docking-ready output for molecular docking software:
//! - AutoDock Vina box parameters
//! - Pharmacophore feature extraction
//! - PDBQT-compatible output
//! - Grid box visualization
//!
//! Enables seamless integration with docking workflows.

use crate::pocket::Pocket;
use crate::structure::Atom;
use serde::{Deserialize, Serialize};
use std::fs;
use std::io::Write;
use std::path::Path;

/// AutoDock Vina docking box parameters
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VinaBox {
    /// Center X coordinate (Å)
    pub center_x: f64,
    /// Center Y coordinate (Å)
    pub center_y: f64,
    /// Center Z coordinate (Å)
    pub center_z: f64,
    /// Box size X (Å)
    pub size_x: f64,
    /// Box size Y (Å)
    pub size_y: f64,
    /// Box size Z (Å)
    pub size_z: f64,
    /// Grid spacing (Å, typically 0.375)
    pub spacing: f64,
    /// Exhaustiveness parameter (default 8)
    pub exhaustiveness: u32,
    /// Number of binding modes to generate
    pub num_modes: u32,
    /// Energy range (kcal/mol)
    pub energy_range: f64,
}

impl Default for VinaBox {
    fn default() -> Self {
        Self {
            center_x: 0.0,
            center_y: 0.0,
            center_z: 0.0,
            size_x: 20.0,
            size_y: 20.0,
            size_z: 20.0,
            spacing: 0.375,
            exhaustiveness: 8,
            num_modes: 9,
            energy_range: 3.0,
        }
    }
}

impl VinaBox {
    /// Create from pocket centroid with automatic box sizing
    pub fn from_pocket(pocket: &Pocket, atoms: &[Atom], padding: f64) -> Self {
        // Get pocket atom coordinates
        let coords: Vec<[f64; 3]> = pocket
            .atom_indices
            .iter()
            .filter_map(|&idx| atoms.get(idx).map(|a| a.coord))
            .collect();

        if coords.is_empty() {
            return Self {
                center_x: pocket.centroid[0],
                center_y: pocket.centroid[1],
                center_z: pocket.centroid[2],
                ..Default::default()
            };
        }

        // Calculate bounding box
        let mut min = [f64::INFINITY; 3];
        let mut max = [f64::NEG_INFINITY; 3];

        for c in &coords {
            for i in 0..3 {
                min[i] = min[i].min(c[i]);
                max[i] = max[i].max(c[i]);
            }
        }

        // Add padding
        let size_x = (max[0] - min[0] + 2.0 * padding).max(15.0);
        let size_y = (max[1] - min[1] + 2.0 * padding).max(15.0);
        let size_z = (max[2] - min[2] + 2.0 * padding).max(15.0);

        Self {
            center_x: pocket.centroid[0],
            center_y: pocket.centroid[1],
            center_z: pocket.centroid[2],
            size_x,
            size_y,
            size_z,
            ..Default::default()
        }
    }

    /// Generate Vina config file content
    pub fn to_config(&self, receptor: &str, ligand: &str, output: &str) -> String {
        format!(
            r#"# AutoDock Vina configuration file
# Generated by PRISM-LBS

receptor = {}
ligand = {}
out = {}

center_x = {:.3}
center_y = {:.3}
center_z = {:.3}

size_x = {:.1}
size_y = {:.1}
size_z = {:.1}

exhaustiveness = {}
num_modes = {}
energy_range = {:.1}
"#,
            receptor,
            ligand,
            output,
            self.center_x,
            self.center_y,
            self.center_z,
            self.size_x,
            self.size_y,
            self.size_z,
            self.exhaustiveness,
            self.num_modes,
            self.energy_range,
        )
    }

    /// Generate command line for Vina
    pub fn to_command(&self, receptor: &str, ligand: &str, output: &str) -> String {
        format!(
            "vina --receptor {} --ligand {} --out {} \
             --center_x {:.3} --center_y {:.3} --center_z {:.3} \
             --size_x {:.1} --size_y {:.1} --size_z {:.1} \
             --exhaustiveness {} --num_modes {}",
            receptor,
            ligand,
            output,
            self.center_x,
            self.center_y,
            self.center_z,
            self.size_x,
            self.size_y,
            self.size_z,
            self.exhaustiveness,
            self.num_modes,
        )
    }

    /// Save config file
    pub fn save_config(&self, path: &Path, receptor: &str, ligand: &str, output: &str) -> std::io::Result<()> {
        let config = self.to_config(receptor, ligand, output);
        fs::write(path, config)
    }

    /// Generate PyMOL visualization script for the box
    pub fn to_pymol_script(&self, name: &str) -> String {
        let half_x = self.size_x / 2.0;
        let half_y = self.size_y / 2.0;
        let half_z = self.size_z / 2.0;

        format!(
            r#"# PyMOL script to visualize docking box
# Generated by PRISM-LBS

from pymol import cmd
from pymol.cgo import *

# Box vertices
box_{} = [
    LINEWIDTH, 2.0,
    BEGIN, LINES,
    COLOR, 0.0, 1.0, 0.0,  # Green

    # Bottom face
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},

    # Top face
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},

    # Vertical edges
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},
    VERTEX, {:.3}, {:.3}, {:.3},

    END
]

cmd.load_cgo(box_{}, "docking_box_{}")
cmd.pseudoatom("box_center_{}", pos=[{:.3}, {:.3}, {:.3}])
cmd.show("spheres", "box_center_{}")
cmd.set("sphere_scale", 0.5, "box_center_{}")
"#,
            name,
            // Bottom face
            self.center_x - half_x, self.center_y - half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x - half_x, self.center_y - half_y, self.center_z - half_z,
            // Top face
            self.center_x - half_x, self.center_y - half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z + half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z + half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z + half_z,
            self.center_x - half_x, self.center_y - half_y, self.center_z + half_z,
            // Vertical edges
            self.center_x - half_x, self.center_y - half_y, self.center_z - half_z,
            self.center_x - half_x, self.center_y - half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y - half_y, self.center_z + half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x + half_x, self.center_y + half_y, self.center_z + half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z - half_z,
            self.center_x - half_x, self.center_y + half_y, self.center_z + half_z,
            name, name, name,
            self.center_x, self.center_y, self.center_z,
            name, name,
        )
    }
}

/// Pharmacophore feature types
#[derive(Debug, Clone, Copy, Serialize, Deserialize, PartialEq, Eq, Hash)]
pub enum PharmacophoreType {
    /// Hydrogen bond donor (OH, NH)
    HBondDonor,
    /// Hydrogen bond acceptor (O, N with lone pairs)
    HBondAcceptor,
    /// Hydrophobic region
    Hydrophobic,
    /// Aromatic ring center
    Aromatic,
    /// Positive charge center
    PositiveCharge,
    /// Negative charge center
    NegativeCharge,
    /// Metal binding site
    MetalBinding,
}

impl PharmacophoreType {
    pub fn as_str(&self) -> &'static str {
        match self {
            PharmacophoreType::HBondDonor => "HBD",
            PharmacophoreType::HBondAcceptor => "HBA",
            PharmacophoreType::Hydrophobic => "HYD",
            PharmacophoreType::Aromatic => "ARO",
            PharmacophoreType::PositiveCharge => "POS",
            PharmacophoreType::NegativeCharge => "NEG",
            PharmacophoreType::MetalBinding => "MET",
        }
    }

    pub fn color(&self) -> (f64, f64, f64) {
        match self {
            PharmacophoreType::HBondDonor => (0.0, 0.5, 1.0),     // Blue
            PharmacophoreType::HBondAcceptor => (1.0, 0.0, 0.0),  // Red
            PharmacophoreType::Hydrophobic => (1.0, 1.0, 0.0),    // Yellow
            PharmacophoreType::Aromatic => (1.0, 0.5, 0.0),       // Orange
            PharmacophoreType::PositiveCharge => (0.0, 0.0, 1.0), // Dark blue
            PharmacophoreType::NegativeCharge => (0.5, 0.0, 0.0), // Dark red
            PharmacophoreType::MetalBinding => (0.5, 0.5, 0.5),   // Gray
        }
    }
}

/// Single pharmacophore feature
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PharmacophoreFeature {
    /// Feature type
    pub feature_type: PharmacophoreType,
    /// Center position (Å)
    pub position: [f64; 3],
    /// Radius/tolerance (Å)
    pub radius: f64,
    /// Direction vector (for directional features like HBD/HBA)
    pub direction: Option<[f64; 3]>,
    /// Contributing residues
    pub residues: Vec<String>,
    /// Weight/importance
    pub weight: f64,
}

/// Pharmacophore model for a binding site
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct PharmacophoreModel {
    /// Pocket ID
    pub pocket_id: usize,
    /// All features
    pub features: Vec<PharmacophoreFeature>,
    /// Feature counts by type
    pub feature_counts: std::collections::HashMap<String, usize>,
    /// Overall model quality
    pub quality_score: f64,
}

impl PharmacophoreModel {
    /// Extract pharmacophore from pocket
    pub fn from_pocket(pocket: &Pocket, atoms: &[Atom], pocket_id: usize) -> Self {
        let mut features = Vec::new();

        // Group atoms by residue
        let mut residue_atoms: std::collections::HashMap<(i32, char), Vec<&Atom>> =
            std::collections::HashMap::new();

        for &idx in &pocket.atom_indices {
            if let Some(atom) = atoms.get(idx) {
                residue_atoms
                    .entry((atom.residue_seq, atom.chain_id))
                    .or_default()
                    .push(atom);
            }
        }

        // Extract features from each residue
        for ((res_seq, chain), res_atoms) in &residue_atoms {
            let res_name = res_atoms
                .first()
                .map(|a| a.residue_name.as_str())
                .unwrap_or("");

            let res_label = format!("{}{}{}", res_name, res_seq, chain);

            // H-bond donors
            if matches!(res_name, "SER" | "THR" | "TYR" | "ASN" | "GLN" | "TRP" | "HIS" | "LYS" | "ARG") {
                if let Some(pos) = Self::find_hbd_position(res_atoms, res_name) {
                    features.push(PharmacophoreFeature {
                        feature_type: PharmacophoreType::HBondDonor,
                        position: pos,
                        radius: 1.5,
                        direction: None,
                        residues: vec![res_label.clone()],
                        weight: 1.0,
                    });
                }
            }

            // H-bond acceptors
            if matches!(res_name, "SER" | "THR" | "TYR" | "ASN" | "GLN" | "ASP" | "GLU" | "HIS") {
                if let Some(pos) = Self::find_hba_position(res_atoms, res_name) {
                    features.push(PharmacophoreFeature {
                        feature_type: PharmacophoreType::HBondAcceptor,
                        position: pos,
                        radius: 1.5,
                        direction: None,
                        residues: vec![res_label.clone()],
                        weight: 1.0,
                    });
                }
            }

            // Hydrophobic
            if matches!(res_name, "ALA" | "VAL" | "LEU" | "ILE" | "MET" | "PHE" | "TRP" | "PRO") {
                let centroid = Self::calculate_centroid(res_atoms);
                features.push(PharmacophoreFeature {
                    feature_type: PharmacophoreType::Hydrophobic,
                    position: centroid,
                    radius: 2.0,
                    direction: None,
                    residues: vec![res_label.clone()],
                    weight: 1.0,
                });
            }

            // Aromatic
            if matches!(res_name, "PHE" | "TYR" | "TRP" | "HIS") {
                if let Some(pos) = Self::find_ring_center(res_atoms, res_name) {
                    features.push(PharmacophoreFeature {
                        feature_type: PharmacophoreType::Aromatic,
                        position: pos,
                        radius: 1.5,
                        direction: None,
                        residues: vec![res_label.clone()],
                        weight: 1.0,
                    });
                }
            }

            // Charged
            if matches!(res_name, "LYS" | "ARG" | "HIS") {
                let centroid = Self::calculate_centroid(res_atoms);
                features.push(PharmacophoreFeature {
                    feature_type: PharmacophoreType::PositiveCharge,
                    position: centroid,
                    radius: 2.0,
                    direction: None,
                    residues: vec![res_label.clone()],
                    weight: 0.8,
                });
            }

            if matches!(res_name, "ASP" | "GLU") {
                let centroid = Self::calculate_centroid(res_atoms);
                features.push(PharmacophoreFeature {
                    feature_type: PharmacophoreType::NegativeCharge,
                    position: centroid,
                    radius: 2.0,
                    direction: None,
                    residues: vec![res_label.clone()],
                    weight: 0.8,
                });
            }
        }

        // Cluster nearby features of same type
        let clustered_features = Self::cluster_features(features);

        // Count features
        let mut feature_counts = std::collections::HashMap::new();
        for f in &clustered_features {
            *feature_counts
                .entry(f.feature_type.as_str().to_string())
                .or_insert(0) += 1;
        }

        // Calculate quality score
        let quality_score = Self::calculate_quality(&clustered_features);

        PharmacophoreModel {
            pocket_id,
            features: clustered_features,
            feature_counts,
            quality_score,
        }
    }

    fn find_hbd_position(atoms: &[&Atom], res_name: &str) -> Option<[f64; 3]> {
        let target_atoms = match res_name {
            "SER" => vec!["OG"],
            "THR" => vec!["OG1"],
            "TYR" => vec!["OH"],
            "ASN" => vec!["ND2"],
            "GLN" => vec!["NE2"],
            "TRP" => vec!["NE1"],
            "HIS" => vec!["ND1", "NE2"],
            "LYS" => vec!["NZ"],
            "ARG" => vec!["NH1", "NH2"],
            _ => vec![],
        };

        for atom in atoms {
            if target_atoms.contains(&atom.name.trim()) {
                return Some(atom.coord);
            }
        }
        None
    }

    fn find_hba_position(atoms: &[&Atom], res_name: &str) -> Option<[f64; 3]> {
        let target_atoms = match res_name {
            "SER" => vec!["OG"],
            "THR" => vec!["OG1"],
            "TYR" => vec!["OH"],
            "ASN" => vec!["OD1"],
            "GLN" => vec!["OE1"],
            "ASP" => vec!["OD1", "OD2"],
            "GLU" => vec!["OE1", "OE2"],
            "HIS" => vec!["ND1", "NE2"],
            _ => vec![],
        };

        for atom in atoms {
            if target_atoms.contains(&atom.name.trim()) {
                return Some(atom.coord);
            }
        }
        None
    }

    fn find_ring_center(atoms: &[&Atom], res_name: &str) -> Option<[f64; 3]> {
        let ring_atoms = match res_name {
            "PHE" => vec!["CG", "CD1", "CD2", "CE1", "CE2", "CZ"],
            "TYR" => vec!["CG", "CD1", "CD2", "CE1", "CE2", "CZ"],
            "TRP" => vec!["CG", "CD1", "CD2", "NE1", "CE2", "CE3", "CZ2", "CZ3", "CH2"],
            "HIS" => vec!["CG", "ND1", "CD2", "CE1", "NE2"],
            _ => vec![],
        };

        let ring_coords: Vec<[f64; 3]> = atoms
            .iter()
            .filter(|a| ring_atoms.contains(&a.name.trim()))
            .map(|a| a.coord)
            .collect();

        if ring_coords.is_empty() {
            return None;
        }

        Some(Self::calculate_centroid_coords(&ring_coords))
    }

    fn calculate_centroid(atoms: &[&Atom]) -> [f64; 3] {
        let coords: Vec<[f64; 3]> = atoms.iter().map(|a| a.coord).collect();
        Self::calculate_centroid_coords(&coords)
    }

    fn calculate_centroid_coords(coords: &[[f64; 3]]) -> [f64; 3] {
        if coords.is_empty() {
            return [0.0, 0.0, 0.0];
        }
        let n = coords.len() as f64;
        let sum = coords.iter().fold([0.0, 0.0, 0.0], |acc, c| {
            [acc[0] + c[0], acc[1] + c[1], acc[2] + c[2]]
        });
        [sum[0] / n, sum[1] / n, sum[2] / n]
    }

    fn cluster_features(features: Vec<PharmacophoreFeature>) -> Vec<PharmacophoreFeature> {
        // Simple clustering: merge features of same type within 3Å
        let cluster_threshold = 3.0;
        let mut clustered: Vec<PharmacophoreFeature> = Vec::new();

        for feature in features {
            let mut merged = false;

            for existing in &mut clustered {
                if existing.feature_type == feature.feature_type {
                    let dist = Self::distance(&existing.position, &feature.position);
                    if dist < cluster_threshold {
                        // Merge: average position, combine residues
                        existing.position = [
                            (existing.position[0] + feature.position[0]) / 2.0,
                            (existing.position[1] + feature.position[1]) / 2.0,
                            (existing.position[2] + feature.position[2]) / 2.0,
                        ];
                        existing.residues.extend(feature.residues.clone());
                        existing.weight = (existing.weight + feature.weight) / 2.0;
                        merged = true;
                        break;
                    }
                }
            }

            if !merged {
                clustered.push(feature);
            }
        }

        clustered
    }

    fn distance(a: &[f64; 3], b: &[f64; 3]) -> f64 {
        ((a[0] - b[0]).powi(2) + (a[1] - b[1]).powi(2) + (a[2] - b[2]).powi(2)).sqrt()
    }

    fn calculate_quality(features: &[PharmacophoreFeature]) -> f64 {
        // Quality based on feature diversity and count
        let has_hbd = features
            .iter()
            .any(|f| f.feature_type == PharmacophoreType::HBondDonor);
        let has_hba = features
            .iter()
            .any(|f| f.feature_type == PharmacophoreType::HBondAcceptor);
        let has_hyd = features
            .iter()
            .any(|f| f.feature_type == PharmacophoreType::Hydrophobic);
        let has_aro = features
            .iter()
            .any(|f| f.feature_type == PharmacophoreType::Aromatic);

        let diversity = [has_hbd, has_hba, has_hyd, has_aro]
            .iter()
            .filter(|&&x| x)
            .count() as f64
            / 4.0;

        let count_score = (features.len() as f64 / 10.0).min(1.0);

        (diversity * 0.6 + count_score * 0.4).clamp(0.0, 1.0)
    }

    /// Export to MOE pharmacophore format (.ph4)
    pub fn to_ph4(&self) -> String {
        let mut output = String::new();
        output.push_str("#moe:ph4query\n");
        output.push_str(&format!("# PRISM-LBS Pharmacophore Model - Pocket {}\n", self.pocket_id));

        for (i, feature) in self.features.iter().enumerate() {
            output.push_str(&format!(
                "Feature {} {} {:.3} {:.3} {:.3} {:.2}\n",
                i + 1,
                feature.feature_type.as_str(),
                feature.position[0],
                feature.position[1],
                feature.position[2],
                feature.radius
            ));
        }

        output
    }

    /// Generate PyMOL visualization script
    pub fn to_pymol_script(&self) -> String {
        let mut script = String::new();
        script.push_str("# PRISM-LBS Pharmacophore Visualization\n");
        script.push_str("from pymol import cmd\nfrom pymol.cgo import *\n\n");

        for (i, feature) in self.features.iter().enumerate() {
            let (r, g, b) = feature.feature_type.color();
            script.push_str(&format!(
                "cmd.pseudoatom('pharma_{}_{}'",
                feature.feature_type.as_str(),
                i
            ));
            script.push_str(&format!(
                ", pos=[{:.3}, {:.3}, {:.3}])\n",
                feature.position[0], feature.position[1], feature.position[2]
            ));
            script.push_str(&format!(
                "cmd.color('0x{:02X}{:02X}{:02X}', 'pharma_{}_{}\')\n",
                (r * 255.0) as u8,
                (g * 255.0) as u8,
                (b * 255.0) as u8,
                feature.feature_type.as_str(),
                i
            ));
            script.push_str(&format!(
                "cmd.set('sphere_scale', {:.2}, 'pharma_{}_{}\')\n",
                feature.radius / 2.0,
                feature.feature_type.as_str(),
                i
            ));
            script.push_str(&format!(
                "cmd.show('spheres', 'pharma_{}_{}\')\n\n",
                feature.feature_type.as_str(),
                i
            ));
        }

        script.push_str("cmd.group('pharmacophore', 'pharma_*')\n");
        script
    }
}

/// Docking site generator combining box and pharmacophore
pub struct DockingSiteGenerator {
    /// Padding around pocket for docking box
    pub box_padding: f64,
    /// Exhaustiveness for Vina
    pub exhaustiveness: u32,
}

impl Default for DockingSiteGenerator {
    fn default() -> Self {
        Self {
            box_padding: 5.0,
            exhaustiveness: 8,
        }
    }
}

impl DockingSiteGenerator {
    pub fn new() -> Self {
        Self::default()
    }

    /// Generate complete docking site package
    pub fn generate(&self, pocket: &Pocket, atoms: &[Atom], pocket_id: usize) -> DockingSite {
        let vina_box = VinaBox::from_pocket(pocket, atoms, self.box_padding);
        let pharmacophore = PharmacophoreModel::from_pocket(pocket, atoms, pocket_id);

        DockingSite {
            pocket_id,
            vina_box,
            pharmacophore,
            pocket_volume: pocket.volume,
            druggability: pocket.druggability_score.total,
        }
    }

    /// Generate and save all docking files
    pub fn save_docking_files(
        &self,
        pocket: &Pocket,
        atoms: &[Atom],
        output_dir: &Path,
        receptor_name: &str,
        pocket_id: usize,
    ) -> std::io::Result<()> {
        fs::create_dir_all(output_dir)?;

        let site = self.generate(pocket, atoms, pocket_id);
        let prefix = format!("pocket_{}", pocket_id);

        // Save Vina config
        let config_path = output_dir.join(format!("{}_vina.txt", prefix));
        site.vina_box.save_config(
            &config_path,
            &format!("{}.pdbqt", receptor_name),
            "ligand.pdbqt",
            &format!("{}_docked.pdbqt", prefix),
        )?;

        // Save pharmacophore
        let ph4_path = output_dir.join(format!("{}.ph4", prefix));
        fs::write(&ph4_path, site.pharmacophore.to_ph4())?;

        // Save PyMOL script
        let pml_path = output_dir.join(format!("{}_visualization.pml", prefix));
        let mut pml_content = site.vina_box.to_pymol_script(&prefix);
        pml_content.push_str(&site.pharmacophore.to_pymol_script());
        fs::write(&pml_path, pml_content)?;

        // Save JSON summary
        let json_path = output_dir.join(format!("{}_docking.json", prefix));
        let json = serde_json::to_string_pretty(&site).map_err(|e| {
            std::io::Error::new(std::io::ErrorKind::Other, e.to_string())
        })?;
        fs::write(&json_path, json)?;

        Ok(())
    }
}

/// Complete docking site information
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct DockingSite {
    pub pocket_id: usize,
    pub vina_box: VinaBox,
    pub pharmacophore: PharmacophoreModel,
    pub pocket_volume: f64,
    pub druggability: f64,
}
