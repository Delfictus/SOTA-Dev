# PRISM-4D Cryptic Site Detection Pipeline
## ANM Ensemble Generation, Volume Tracking & GPU SASA Implementation

**Version:** 1.1.0
**Last Updated:** 2026-01-19
**Status:** Production-ready GPU SASA, ANM-based ensemble (see limitations)

---

## Table of Contents

1. [Pipeline Overview](#1-pipeline-overview)
2. [ANM Ensemble Generation](#2-anm-ensemble-generation)
3. [Volume Tracking & Centroid Matching](#3-volume-tracking--centroid-matching)
4. [GPU LCPO SASA Implementation](#4-gpu-lcpo-sasa-implementation)
5. [Current Limitations](#5-current-limitations)
6. [Future MD-Based Pipeline Integration](#6-future-md-based-pipeline-integration)
7. [API Reference](#7-api-reference)

---

## 1. Pipeline Overview

The cryptic site detection pipeline identifies **cryptic binding sites** - pockets that are not visible in the static X-ray structure but transiently open during protein dynamics. Detection is based on measuring **volume variance** across a conformational ensemble.

### Pipeline Steps

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    CRYPTIC SITE DETECTION PIPELINE                          │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. INPUT                                                                   │
│     └── prism-prep topology JSON (sanitized structure with AMBER params)    │
│                                                                             │
│  2. ENSEMBLE GENERATION (ANM v2)                                            │
│     ├── Build Hessian matrix from Cα coordinates                           │
│     ├── Eigendecomposition → normal modes                                   │
│     └── Sample 100 conformations via thermal mode amplitudes                │
│                                                                             │
│  3. ALIGNMENT                                                               │
│     └── Kabsch alignment of all frames to reference structure               │
│                                                                             │
│  4. GPU SASA CALCULATION                                                    │
│     └── LCPO SASA for all atoms (single frame, used for druggability)       │
│                                                                             │
│  5. POCKET DETECTION (per frame)                                            │
│     ├── Local neighbor density analysis                                     │
│     ├── Identify concave regions (6-15 neighbors within 10Å)                │
│     └── Merge overlapping pockets                                           │
│                                                                             │
│  6. VOLUME TRACKING                                                         │
│     ├── Match pockets across frames by centroid proximity (8Å threshold)    │
│     ├── Compute volume statistics (mean, std, CV)                           │
│     └── Classify cryptic sites: CV > 20%, open_frequency 5-90%              │
│                                                                             │
│  7. OUTPUTS                                                                 │
│     ├── Multi-MODEL PDB trajectory                                          │
│     ├── Volume CSV time series                                              │
│     ├── RMSF CSV                                                            │
│     └── HTML executive report                                               │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### Key Files

| File | Purpose |
|------|---------|
| `crates/prism-validation/src/cryptic_site_pilot/pipeline.rs` | Main orchestrator |
| `crates/prism-validation/src/anm_ensemble_v2.rs` | ANM conformational sampling |
| `crates/prism-validation/src/cryptic_site_pilot/volume_tracker.rs` | Pocket tracking |
| `crates/prism-gpu/src/lcpo_sasa.rs` | GPU SASA Rust bindings |
| `crates/prism-gpu/src/kernels/lcpo_sasa.cu` | GPU SASA CUDA kernel |

---

## 2. ANM Ensemble Generation

### 2.1 Physics Background

**Anisotropic Network Model (ANM)** treats the protein as an elastic network where Cα atoms are connected by springs. The dynamics are described by harmonic oscillations around the equilibrium structure.

```
Hessian Matrix H (3N × 3N):
  H_ij = -γ * (r_ij ⊗ r_ij) / |r_ij|²    if |r_ij| < cutoff
  H_ii = -Σ H_ij                          (diagonal)

Eigendecomposition:
  H = V Λ V^T

  λ_k = eigenvalues (mode frequencies/stiffness)
  v_k = eigenvectors (mode shapes)
```

### 2.2 Conformation Sampling

Conformations are generated by sampling mode amplitudes from the thermal (Boltzmann) distribution:

```
New conformation:
  x' = x₀ + Σₖ (aₖ * vₖ)

Where:
  aₖ ~ N(0, √(kT/λₖ))     # Thermal amplitude for mode k
  vₖ = eigenvector of mode k
  kT = Boltzmann constant × temperature
```

### 2.3 ANM v2 Parameters

```rust
// crates/prism-validation/src/anm_ensemble_v2.rs

pub struct AnmEnsembleConfigV2 {
    pub cutoff: f64,           // 15.0 Å - distance cutoff for contacts
    pub gamma: f64,            // 1.0 - spring constant
    pub temperature: f64,      // 310.0 K - body temperature
    pub n_conformations: usize, // 100 - frames to generate
    pub n_modes: usize,        // 30 - modes to sample (excluding 6 rigid-body)
    pub amplitude_scale: f64,  // 5.0 - scaling factor for larger motions
    pub max_displacement: f64, // 8.0 Å - per-residue displacement limit
    pub seed: Option<u64>,     // Random seed for reproducibility
}
```

### 2.4 ANM Algorithm

```rust
pub fn generate_ensemble(&mut self, ca_positions: &[[f32; 3]]) -> Result<AnmEnsembleV2> {
    // 1. Build Hessian matrix
    let hessian = self.build_hessian(ca_positions);

    // 2. Eigendecomposition (nalgebra SymmetricEigen)
    let decomp = SymmetricEigen::new(hessian);

    // 3. Skip first 6 modes (rigid-body: translation + rotation)
    let valid_modes = &decomp.eigenvalues[6..];
    let valid_vectors = &decomp.eigenvectors.columns(6..);

    // 4. Generate conformations
    let mut conformations = Vec::new();
    for _ in 0..self.config.n_conformations {
        let mut new_coords = ca_positions.clone();

        for (mode_idx, &eigenvalue) in valid_modes.iter().enumerate().take(self.config.n_modes) {
            // Sample amplitude from thermal distribution
            let sigma = (self.config.amplitude_scale * KB * self.config.temperature / eigenvalue).sqrt();
            let amplitude = rng.sample(Normal::new(0.0, sigma));

            // Apply mode displacement
            let eigenvector = valid_vectors.column(mode_idx);
            for i in 0..n_residues {
                new_coords[i][0] += (amplitude * eigenvector[i*3 + 0]) as f32;
                new_coords[i][1] += (amplitude * eigenvector[i*3 + 1]) as f32;
                new_coords[i][2] += (amplitude * eigenvector[i*3 + 2]) as f32;
            }
        }

        // Clamp maximum displacement
        self.clamp_displacement(&mut new_coords, ca_positions);
        conformations.push(new_coords);
    }

    Ok(AnmEnsembleV2 { conformations, ... })
}
```

### 2.5 ANM Limitations

| Limitation | Impact |
|------------|--------|
| **Cα-only coordinates** | Cannot capture side-chain movements that define pocket boundaries |
| **Harmonic approximation** | Misses anharmonic (large amplitude) motions |
| **No solvent effects** | Cryptic pockets often involve water displacement |
| **Global collective modes** | May miss localized pocket "breathing" |

---

## 3. Volume Tracking & Centroid Matching

### 3.1 Pocket Detection (Per Frame)

The current implementation uses a simplified neighbor-density method:

```rust
// crates/prism-validation/src/cryptic_site_pilot/pipeline.rs

fn detect_pockets_in_frame(&self, coords: &[[f32; 3]]) -> Vec<([f64; 3], f64, Vec<i32>)> {
    let neighbor_cutoff = 10.0f32;  // Å
    let mut pockets = Vec::new();

    for i in 0..n_residues {
        // Count neighbors within cutoff
        let neighbors: Vec<usize> = (0..n_residues)
            .filter(|&j| j != i && distance(coords[i], coords[j]) < neighbor_cutoff)
            .collect();

        // Pocket criterion: moderately buried (6-15 neighbors)
        // Too few = surface, too many = core
        if neighbors.len() >= 6 && neighbors.len() <= 15 {
            let centroid = coords[i];
            let volume = neighbors.len() as f64 * 25.0;  // ~25 Å³ per contact

            if volume >= min_volume && volume <= max_volume {
                pockets.push((centroid, volume, residues));
            }
        }
    }

    // Merge overlapping pockets (≥3 shared residues)
    self.merge_overlapping_pockets(pockets)
}
```

### 3.2 Centroid-Based Tracking

Pockets are matched across frames using centroid proximity:

```rust
// crates/prism-validation/src/cryptic_site_pilot/volume_tracker.rs

pub struct VolumeTracker {
    pub min_open_volume: f64,           // 100.0 Å³
    pub centroid_match_distance: f64,   // 8.0 Å
    pub min_frames_for_tracking: usize, // 5 frames minimum
    pockets: HashMap<String, VolumeTimeSeries>,
}

fn find_matching_pocket(&self, centroid: &[f64; 3]) -> Option<String> {
    let dist_sq_threshold = self.centroid_match_distance * self.centroid_match_distance;

    for (id, pocket) in &self.pockets {
        if let Some(last_frame) = pocket.frames.last() {
            let dx = centroid[0] - last_frame.centroid[0];
            let dy = centroid[1] - last_frame.centroid[1];
            let dz = centroid[2] - last_frame.centroid[2];
            let dist_sq = dx*dx + dy*dy + dz*dz;

            if dist_sq < dist_sq_threshold {
                return Some(id.clone());  // Match found
            }
        }
    }
    None  // New pocket
}
```

### 3.3 Cryptic Site Classification

```rust
// After processing all frames
pub fn finalize(&mut self) {
    for pocket in self.pockets.values_mut() {
        pocket.recompute_statistics();

        // Cryptic site criteria:
        // 1. High volume variance (CV > 20%) - indicates "breathing"
        // 2. Partial opening (5-90% of frames) - not always open or closed
        pocket.is_cryptic = pocket.stats.cv_volume > 0.20
            && pocket.stats.open_frequency >= 0.05
            && pocket.stats.open_frequency <= 0.90;
    }
}
```

### 3.4 Volume Statistics

```rust
pub struct VolumeStatistics {
    pub n_frames: usize,           // Frames where pocket was detected
    pub n_open_frames: usize,      // Frames where volume > threshold
    pub open_frequency: f64,       // n_open / n_frames
    pub mean_volume: f64,          // Mean volume when open (Å³)
    pub std_volume: f64,           // Standard deviation
    pub cv_volume: f64,            // Coefficient of variation = std/mean
    pub min_volume: f64,           // Minimum observed
    pub max_volume: f64,           // Maximum observed
    pub breathing_amplitude: f64,  // max - min (pocket "opening")
    pub mean_sasa: f64,            // Mean SASA (Å²)
    pub mean_druggability: Option<f64>,
}
```

### 3.5 Tracking Limitation: Centroid Drift

**Problem:** With ANM deformations, pocket centroids drift >8Å between frames, causing each frame's pockets to be tracked independently.

**Result:**
- Each pocket appears in only 1 frame (`n_frames = 1`)
- `std_volume = 0` (no variance with single observation)
- `cv_volume = 0` → **No cryptic classification possible**

**Solution:** See Section 6 (MD-based pipeline with residue-based tracking).

---

## 4. GPU LCPO SASA Implementation

### 4.1 LCPO Algorithm

**Linear Combination of Pairwise Overlaps (LCPO)** is an analytical approximation for Solvent Accessible Surface Area (SASA).

```
Reference: Weiser, Shenkin, Still (1999) J. Comput. Chem. 20:217-230

SASA_i = P1 * S_i + P2 * Σ(A_ij) + P3 * Σ(A_ij * A_ik) + P4 * S_i * Σ(A_ij²)

Where:
  S_i = 4π(R_i + R_probe)²     # Unoccluded sphere surface
  A_ij = overlap term between atoms i and j
  P1-P4 = LCPO parameters (atom-type specific)
  R_probe = 1.4 Å (water probe radius)
```

### 4.2 GPU Kernel Architecture

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                        GPU LCPO SASA KERNEL                                 │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  CONSTANT MEMORY (fast, read-only):                                         │
│  ├── LCPO_P1[8], LCPO_P2[8], LCPO_P3[8], LCPO_P4[8]  # Per-type params     │
│  └── VDW_RADII[8]                                      # Default radii      │
│                                                                             │
│  SHARED MEMORY TILING (128 atoms per tile):                                 │
│  ├── tile_data[128] = float4(x, y, z, radius+probe)                        │
│  └── tile_types[128] = int                                                  │
│                                                                             │
│  ALGORITHM:                                                                 │
│  ┌─────────────────────────────────────────────────────────────────────┐   │
│  │  1. Each thread loads one atom (i) from global memory               │   │
│  │  2. For each tile of atoms:                                         │   │
│  │     a. Cooperative load: all threads load tile into shared memory   │   │
│  │     b. __syncthreads()                                              │   │
│  │     c. Iterate over tile atoms (j):                                 │   │
│  │        - EARLY EXIT: if |r_ij|² > 81 Å², skip (9Å cutoff)          │   │
│  │        - Compute overlap term A_ij                                  │   │
│  │        - Accumulate P2, P3, P4 sums                                 │   │
│  │     d. __syncthreads()                                              │   │
│  │  3. Compute final SASA using LCPO formula                           │   │
│  │  4. Write result to global memory                                   │   │
│  └─────────────────────────────────────────────────────────────────────┘   │
│                                                                             │
│  COMPLEXITY: O(N × N/TILE_SIZE) → ~O(N) with early exit                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 4.3 CUDA Kernel Code

```cuda
// crates/prism-gpu/src/kernels/lcpo_sasa.cu

#define TILE_SIZE 128        // Atoms per tile
#define LCPO_CUTOFF 9.0f     // Angstrom cutoff
#define LCPO_CUTOFF_SQ 81.0f
#define PROBE_RADIUS 1.4f    // Water probe

// LCPO parameters in constant memory
__constant__ float LCPO_P1[8] = { 0.7887f, ... };
__constant__ float LCPO_P2[8] = {-0.3556f, ... };
__constant__ float LCPO_P3[8] = {-0.0018f, ... };
__constant__ float LCPO_P4[8] = { 0.0052f, ... };
__constant__ float VDW_RADII[8] = { 1.70f, 1.70f, 1.55f, 1.52f, 1.80f, 1.80f, 1.20f, 1.70f };

// Overlap term calculation
__device__ __forceinline__ float compute_overlap_term(float ri, float rj, float dist) {
    if (dist < 0.001f || dist >= ri + rj) return 0.0f;

    float ri_sq = ri * ri;
    float rj_sq = rj * rj;
    float term1 = ri - dist * 0.5f;
    float term2 = (ri_sq - rj_sq) / (2.0f * dist);

    return fmaxf(PI * ri * (term1 - term2), 0.0f);
}

extern "C" __global__ void lcpo_sasa_kernel(
    const float* positions,     // [n_atoms * 3]
    const int* atom_types,      // [n_atoms]
    const float* radii,         // [n_atoms] or NULL
    const int n_atoms,
    float* sasa_out             // [n_atoms]
) {
    __shared__ float4 tile_data[TILE_SIZE];
    __shared__ int tile_types[TILE_SIZE];

    const int i = blockIdx.x * blockDim.x + threadIdx.x;

    // Load atom i data
    float3 pos_i;
    float ri, Si;
    int type_i;
    if (i < n_atoms) {
        pos_i = make_float3(positions[i*3], positions[i*3+1], positions[i*3+2]);
        type_i = atom_types[i];
        float vdw_r = (radii != nullptr) ? radii[i] : VDW_RADII[type_i];
        ri = vdw_r + PROBE_RADIUS;
        Si = 4.0f * PI * ri * ri;  // Unoccluded surface
    }

    // Accumulate LCPO terms
    float sum_Aij = 0.0f, sum_Aij_Aik = 0.0f, sum_Aij_sq = 0.0f;

    // Iterate over tiles
    const int n_tiles = (n_atoms + TILE_SIZE - 1) / TILE_SIZE;
    for (int tile = 0; tile < n_tiles; tile++) {
        // Cooperative load into shared memory
        int j_load = tile * TILE_SIZE + threadIdx.x;
        if (j_load < n_atoms) {
            float vdw_r = (radii != nullptr) ? radii[j_load] : VDW_RADII[atom_types[j_load]];
            tile_data[threadIdx.x] = make_float4(
                positions[j_load*3], positions[j_load*3+1], positions[j_load*3+2],
                vdw_r + PROBE_RADIUS
            );
            tile_types[threadIdx.x] = atom_types[j_load];
        }
        __syncthreads();

        // Process tile
        if (i < n_atoms) {
            #pragma unroll 8
            for (int k = 0; k < TILE_SIZE; k++) {
                int j = tile * TILE_SIZE + k;
                if (j >= n_atoms || j == i) continue;

                float4 data_j = tile_data[k];
                float dx = data_j.x - pos_i.x;
                float dy = data_j.y - pos_i.y;
                float dz = data_j.z - pos_i.z;
                float dist_sq = dx*dx + dy*dy + dz*dz;

                // EARLY EXIT: ~90% of pairs skipped
                if (dist_sq > LCPO_CUTOFF_SQ) continue;

                float dist = sqrtf(dist_sq);
                float Aij = compute_overlap_term(ri, data_j.w, dist);

                if (Aij > 0.0f) {
                    sum_Aij += Aij;
                    sum_Aij_sq += Aij * Aij;
                    sum_Aij_Aik += Aij;
                }
            }
        }
        __syncthreads();
    }

    // Compute final SASA
    if (i < n_atoms) {
        float P1 = LCPO_P1[type_i], P2 = LCPO_P2[type_i];
        float P3 = LCPO_P3[type_i], P4 = LCPO_P4[type_i];

        // P3 term approximation
        float n_neighbors = sum_Aij / (PI * ri * 0.5f + 0.001f);
        float Aij_Aik_term = (n_neighbors > 1.0f) ?
            sum_Aij_Aik * sum_Aij_Aik / n_neighbors : 0.0f;

        float sasa = P1 * Si + P2 * sum_Aij + P3 * Aij_Aik_term + P4 * Si * sum_Aij_sq;
        sasa_out[i] = fmaxf(sasa, 0.0f);
    }
}
```

### 4.4 Rust FFI Bindings

```rust
// crates/prism-gpu/src/lcpo_sasa.rs

pub struct LcpoSasaGpu {
    context: Arc<CudaContext>,
    stream: Arc<CudaStream>,
    lcpo_kernel: CudaFunction,
    lcpo_batched_kernel: CudaFunction,
    sum_kernel: CudaFunction,
    residue_kernel: CudaFunction,
}

impl LcpoSasaGpu {
    pub fn new(context: Arc<CudaContext>) -> Result<Self> {
        let stream = context.default_stream();
        let ptx_path = concat!(env!("CARGO_MANIFEST_DIR"), "/target/ptx/lcpo_sasa.ptx");
        let ptx_src = std::fs::read_to_string(ptx_path)?;
        let module = context.load_module(Ptx::from_src(&ptx_src))?;

        Ok(Self {
            context,
            stream,
            lcpo_kernel: module.load_function("lcpo_sasa_kernel")?,
            lcpo_batched_kernel: module.load_function("lcpo_sasa_batched_kernel")?,
            sum_kernel: module.load_function("sum_sasa_kernel")?,
            residue_kernel: module.load_function("residue_sasa_atomic_kernel")?,
        })
    }

    /// Compute SASA for single frame
    pub fn compute(
        &self,
        positions: &[f32],      // [n_atoms * 3]
        atom_types: &[i32],     // [n_atoms]
        radii: Option<&[f32]>,  // [n_atoms] or None
    ) -> Result<SasaResult> {
        let n_atoms = atom_types.len();

        // Allocate device memory
        let d_positions = self.stream.memcpy_htod(positions)?;
        let d_atom_types = self.stream.memcpy_htod(atom_types)?;
        let d_radii = radii.map(|r| self.stream.memcpy_htod(r)).transpose()?;
        let d_sasa: CudaSlice<f32> = self.stream.alloc_zeros(n_atoms)?;

        // Launch kernel
        let blocks = (n_atoms + TILE_SIZE - 1) / TILE_SIZE;
        let cfg = LaunchConfig::for_num_elems(n_atoms as u32);

        let mut builder = self.lcpo_kernel.launch_builder();
        builder
            .arg(&d_positions)
            .arg(&d_atom_types)
            .arg_if(d_radii.as_ref(), |r| r)  // Pass radii or nullptr
            .arg(&(n_atoms as i32))
            .arg(&d_sasa);

        unsafe { builder.launch(cfg) }?;

        // Copy results back
        let mut per_atom = vec![0.0f32; n_atoms];
        self.stream.memcpy_dtoh(&d_sasa, &mut per_atom)?;

        let total: f32 = per_atom.iter().sum();

        Ok(SasaResult { per_atom, total, per_residue: None })
    }

    /// Aggregate per-atom SASA to per-residue
    pub fn aggregate_to_residues(
        &self,
        per_atom_sasa: &[f32],
        residue_map: &[i32],    // [n_atoms] -> residue index
        n_residues: usize,
    ) -> Result<Vec<f32>> {
        // ... GPU kernel for atomic add aggregation ...
    }
}
```

### 4.5 Performance Characteristics

| System | Atoms | Frames | Time | Throughput |
|--------|-------|--------|------|------------|
| 6LU7 (SARS-CoV-2 Mpro) | 4,730 | 100 | ~80ms | 59M atom-frames/s |
| 6M0J (Spike RBD-ACE2) | 12,510 | 100 | ~220ms | 57M atom-frames/s |
| 1BTL (TEM-1 β-lactamase) | 4,073 | 1 | ~0.4ms | 10M atoms/s |

**Key Optimizations:**
- Shared memory tiling reduces global memory bandwidth by 128×
- 9Å cutoff early exit skips ~90% of pairwise calculations
- Constant memory for LCPO parameters (broadcast to all threads)
- `#pragma unroll 8` for inner loop

---

## 5. Current Limitations

### 5.1 ANM Ensemble Limitations

| Issue | Cause | Impact |
|-------|-------|--------|
| Cα-only coordinates | ANM operates on alpha carbons only | Pocket boundaries defined by side chains are missed |
| Centroid drift | ANM deformations move pocket centroids >8Å | Pockets not matched across frames → n_frames=1 |
| Harmonic approximation | Linear response theory | Large-amplitude pocket openings underestimated |
| No solvent | Vacuum dynamics | Cryptic pockets often involve water displacement |

### 5.2 Volume Tracking Limitations

| Issue | Cause | Impact |
|-------|-------|--------|
| Centroid-based matching | 8Å threshold too tight for ANM | Pockets tracked independently per frame |
| Simplified pocket detection | Neighbor count heuristic | May miss deep pockets, over-detect shallow grooves |
| No all-atom volume | Cα positions only | Volume estimates imprecise |

### 5.3 Observed Behavior on 1BTL

```
Test Results (TEM-1 β-lactamase):
- Frames generated: 100
- Pockets detected: 14 (including omega loop region)
- Cryptic sites classified: 0

Per-pocket statistics (all pockets):
- n_frames: 1 (each pocket seen in only 1 frame)
- cv_volume: 0.000 (no variance)
- is_cryptic: false

Root cause: Centroid drift between ANM frames prevents cross-frame matching
```

---

## 6. Future MD-Based Pipeline Integration

### 6.1 Architecture Overview

```
┌─────────────────────────────────────────────────────────────────────────────┐
│                    MD-BASED CRYPTIC SITE PIPELINE (FUTURE)                  │
├─────────────────────────────────────────────────────────────────────────────┤
│                                                                             │
│  1. INPUT                                                                   │
│     └── prism-prep topology JSON                                            │
│                                                                             │
│  2. ENSEMBLE GENERATION (AmberMegaFusedHmc or AmberSimdBatch)              │
│     ├── Full AMBER ff14SB molecular dynamics                                │
│     ├── All-atom coordinates (not just Cα)                                  │
│     └── 100+ frames with proper equilibration                               │
│                                                                             │
│  3. GPU SASA (LCPO) - PER FRAME                                            │
│     ├── Compute SASA for all atoms in each frame                           │
│     └── Aggregate to per-residue SASA                                       │
│                                                                             │
│  4. POCKET DETECTION (fpocket-like or alpha-spheres)                       │
│     ├── All-atom pocket detection                                           │
│     ├── Proper volume calculation                                           │
│     └── Druggability scoring                                                │
│                                                                             │
│  5. RESIDUE-BASED TRACKING                                                  │
│     ├── Match pockets by defining residue overlap (Jaccard index)          │
│     ├── More robust than centroid matching                                  │
│     └── Handles pocket "breathing" and movement                             │
│                                                                             │
│  6. CRYPTIC CLASSIFICATION                                                  │
│     ├── Volume variance (CV > 20%)                                          │
│     ├── SASA variance (independent measure)                                 │
│     └── Combined with druggability score                                    │
│                                                                             │
└─────────────────────────────────────────────────────────────────────────────┘
```

### 6.2 Integration with AmberSimdBatch

```rust
// Example integration (future)

use prism_gpu::{AmberSimdBatch, LcpoSasaGpu, StructureTopology};

pub struct MdCrypticPipeline {
    md_engine: AmberSimdBatch,
    sasa_calculator: LcpoSasaGpu,
    config: CrypticConfig,
}

impl MdCrypticPipeline {
    pub fn run(&mut self, topology: &StructureTopology) -> Result<CrypticResult> {
        // 1. Run MD simulation
        let trajectory = self.md_engine.run_md(
            topology,
            self.config.n_steps,      // 50,000 steps
            self.config.save_interval, // Every 500 steps = 100 frames
        )?;

        // 2. Compute SASA for all frames (batched GPU)
        let all_positions: Vec<f32> = trajectory.frames.iter()
            .flat_map(|f| f.positions.iter().copied())
            .collect();

        let sasa_result = self.sasa_calculator.compute_batched(
            &all_positions,
            &topology.atom_types,
            Some(&topology.radii),
            trajectory.n_frames,
        )?;

        // 3. Detect pockets per frame (all-atom)
        let mut volume_tracker = ResidueBasedVolumeTracker::new();

        for (frame_idx, frame) in trajectory.frames.iter().enumerate() {
            let pockets = self.detect_pockets_allatom(&frame.positions, topology)?;

            for pocket in pockets {
                // Use residue overlap for matching (not centroid)
                volume_tracker.add_observation(
                    frame_idx,
                    &pocket.residues,  // Residue IDs defining pocket
                    pocket.volume,
                    self.sum_residue_sasa(&sasa_result.per_atom[frame_idx], &pocket.residues),
                );
            }
        }

        // 4. Classify cryptic sites
        volume_tracker.finalize();

        Ok(CrypticResult {
            pockets: volume_tracker.get_all(),
            cryptic_sites: volume_tracker.get_cryptic(),
        })
    }
}
```

### 6.3 Residue-Based Pocket Matching

```rust
/// Match pockets by residue overlap instead of centroid distance
pub struct ResidueBasedVolumeTracker {
    pockets: HashMap<String, PocketTimeSeries>,
    jaccard_threshold: f64,  // 0.3 = 30% overlap required
}

impl ResidueBasedVolumeTracker {
    fn find_matching_pocket(&self, residues: &[i32]) -> Option<String> {
        let residue_set: HashSet<i32> = residues.iter().copied().collect();

        for (id, pocket) in &self.pockets {
            let existing_set: HashSet<i32> = pocket.defining_residues.iter().copied().collect();

            // Jaccard index = intersection / union
            let intersection = residue_set.intersection(&existing_set).count();
            let union = residue_set.union(&existing_set).count();
            let jaccard = intersection as f64 / union as f64;

            if jaccard >= self.jaccard_threshold {
                return Some(id.clone());  // Match found
            }
        }
        None  // New pocket
    }
}
```

### 6.4 GPU SASA API for MD Integration

```rust
// Single-frame SASA (for validation/testing)
let sasa = LcpoSasaGpu::new(context)?;
let result = sasa.compute(&positions, &atom_types, Some(&radii))?;
println!("Total SASA: {:.2} Å²", result.total);

// Batched SASA (for trajectories - much faster)
let batch_result = sasa.compute_batched(
    &trajectory_positions,  // [n_frames * n_atoms * 3]
    &atom_types,            // [n_atoms]
    Some(&radii),           // [n_atoms]
    n_frames,
)?;

for (frame, total) in batch_result.totals.iter().enumerate() {
    println!("Frame {}: {:.2} Å²", frame, total);
}

// Aggregate to residues (for pocket-level analysis)
let per_residue = sasa.aggregate_to_residues(
    &result.per_atom,
    &atom_to_residue_map,  // [n_atoms] -> residue index
    n_residues,
)?;
```

---

## 7. API Reference

### 7.1 LcpoSasaGpu

```rust
pub struct LcpoSasaGpu { /* ... */ }

impl LcpoSasaGpu {
    /// Create new GPU SASA calculator
    pub fn new(context: Arc<CudaContext>) -> Result<Self>;

    /// Compute SASA for single frame
    pub fn compute(
        &self,
        positions: &[f32],      // Flat array: [x0, y0, z0, x1, y1, z1, ...]
        atom_types: &[i32],     // AtomType indices (0-7)
        radii: Option<&[f32]>,  // Custom radii or None for defaults
    ) -> Result<SasaResult>;

    /// Compute SASA for multiple frames (batched)
    pub fn compute_batched(
        &self,
        positions: &[f32],      // [n_frames * n_atoms * 3]
        atom_types: &[i32],     // [n_atoms]
        radii: Option<&[f32]>,  // [n_atoms]
        n_frames: usize,
    ) -> Result<BatchedSasaResult>;

    /// Aggregate per-atom SASA to per-residue
    pub fn aggregate_to_residues(
        &self,
        per_atom_sasa: &[f32],
        residue_map: &[i32],
        n_residues: usize,
    ) -> Result<Vec<f32>>;
}
```

### 7.2 AtomType

```rust
#[repr(u8)]
pub enum AtomType {
    CarbonSp3 = 0,   // VDW: 1.70 Å
    CarbonSp2 = 1,   // VDW: 1.70 Å
    Nitrogen = 2,    // VDW: 1.55 Å
    Oxygen = 3,      // VDW: 1.52 Å
    Sulfur = 4,      // VDW: 1.80 Å
    Phosphorus = 5,  // VDW: 1.80 Å
    Hydrogen = 6,    // VDW: 1.20 Å
    Other = 7,       // VDW: 1.70 Å (default)
}

impl AtomType {
    pub fn from_element(element: &str) -> Self;
    pub fn vdw_radius(&self) -> f32;
}
```

### 7.3 Result Types

```rust
pub struct SasaResult {
    pub per_atom: Vec<f32>,           // SASA per atom (Å²)
    pub total: f32,                   // Total SASA (Å²)
    pub per_residue: Option<Vec<f32>>, // Per-residue (if computed)
}

pub struct BatchedSasaResult {
    pub per_atom: Vec<Vec<f32>>,      // [n_frames][n_atoms]
    pub totals: Vec<f32>,              // Total per frame
}
```

### 7.4 Helper Functions

```rust
/// Convert element symbols to atom type indices
pub fn elements_to_atom_types(elements: &[String]) -> Vec<i32> {
    elements.iter()
        .map(|e| AtomType::from_element(e) as i32)
        .collect()
}

/// Convert element symbols to VDW radii
pub fn elements_to_radii(elements: &[String]) -> Vec<f32> {
    elements.iter()
        .map(|e| AtomType::from_element(e).vdw_radius())
        .collect()
}
```

---

## Appendix: Compilation

### Build GPU SASA Kernel

```bash
# Compile CUDA kernel to PTX
nvcc -ptx -arch=sm_60 \
    crates/prism-gpu/src/kernels/lcpo_sasa.cu \
    -o crates/prism-gpu/target/ptx/lcpo_sasa.ptx \
    -I crates/prism-gpu/src/kernels

# Build with GPU feature
cargo build --release -p prism-gpu --features cuda

# Build cryptic site pipeline with GPU SASA
cargo build --release -p prism-validation --features cryptic-gpu
```

### Run Tests

```bash
# Test GPU SASA
cargo test -p prism-gpu --features cuda lcpo_sasa

# Test cryptic pipeline with topology
cargo run --release -p prism-validation --bin cryptic-pilot --features cryptic-gpu -- \
    --topology data/prepared/1BTL_topology.json \
    --output-dir results/1btl_test/
```

---

**Document maintained by:** PRISM-4D Development Team
**Last reviewed:** 2026-01-19
